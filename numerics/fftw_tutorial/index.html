<!DOCTYPE html>
<html lang="en" dir="ltr">

<head>
  <meta name="generator" content="Hugo 0.106.0">
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="FFTW Tutorial # This is a basic C project (Makefile, but also for the Eclipse IDE) I use for exploring FFTW 3.3.9.
One- and two-dimensional discrete Fourier transforms (DFTs) of random data are computed using both FFTW and straight-forward naive algorithms in order to illustrate explicitly what kind of symmetries and scaling properties FFTW implies in its inputs and outputs.
One-Dimensional Examples # This tutorial starts by computing one-dimensional (1D) DFTs of random input data.">
<meta name="theme-color" content="#FFFFFF"><meta property="og:title" content="FFTW Tutorial" />
<meta property="og:description" content="" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://jonathanschilling.github.io/labathome.de/numerics/fftw_tutorial/" />

<title>FFTW Tutorial | Lab@Home</title>
<link rel="manifest" href="/labathome.de/manifest.json">
<link rel="icon" href="/labathome.de/favicon.png" type="image/x-icon">
<link rel="stylesheet" href="/labathome.de/book.min.68be0b7a9674f2a612ce0e9b2e9447ff4b7ac96546e06b642bfd3ded0ca490ef.css" integrity="sha256-aL4LepZ08qYSzg6bLpRH/0t6yWVG4GtkK/097QykkO8=">
<script defer src="/labathome.de/en.search.min.98e7e4703595b4e121b2ad105351ed6a09153cb039fd54e95b8515f4eca1a736.js" integrity="sha256-mOfkcDWVtOEhsq0QU1HtagkVPLA5/VTpW4UV9OyhpzY="></script>
<link rel="alternate" type="application/rss+xml" href="https://jonathanschilling.github.io/labathome.de/numerics/fftw_tutorial/index.xml" title="Lab@Home" />
<script>
  MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      displayMath: [['$$','$$'], ['\\[', '\\]']],
      processEscapes: true,
      processEnvironments: true
    },
    options: {
      skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
    }
  };

  window.addEventListener('load', (event) => {
      document.querySelectorAll("mjx-container").forEach(function(x){
        x.parentElement.classList += 'has-jax'})
    });

</script>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script type="text/javascript" id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  


  
</head>

<body dir="ltr">
  <input type="checkbox" class="hidden toggle" id="menu-control" />
  <input type="checkbox" class="hidden toggle" id="toc-control" />
  <main class="container flex">
    <aside class="book-menu">
      <div class="book-menu-content">
        
  <nav>
<h2 class="book-brand">
  <a href="/labathome.de"><span>Lab@Home</span>
  </a>
</h2>


<div class="book-search">
  <input type="text" id="book-search-input" placeholder="Search" aria-label="Search" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>











  



  
  <ul>
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-88ae3e6ecb3d3fa1ad09b065b750fd2a" class="toggle"  />
    <label for="section-88ae3e6ecb3d3fa1ad09b065b750fd2a" class="flex justify-between">
      <a href="https://jonathanschilling.github.io/labathome.de/elektrotechnik/" class="">Electrical Engineering</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-0222f5b30b3f626d82b5b10c2d02c6fe" class="toggle"  />
    <label for="section-0222f5b30b3f626d82b5b10c2d02c6fe" class="flex justify-between">
      <a  class="">High Voltage</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://jonathanschilling.github.io/labathome.de/elektrotechnik/high_voltage/25kv_transformer/" class="">25kV Transformer</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://jonathanschilling.github.io/labathome.de/elektrotechnik/smps/" class="">SMPS</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-aa15f7083ed8e658e721b252b26a01ae" class="toggle"  />
    <label for="section-aa15f7083ed8e658e721b252b26a01ae" class="flex justify-between">
      <a  class="">Transputer</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://jonathanschilling.github.io/labathome.de/elektrotechnik/transputer/amv_b1/" class="">AVM B1</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://jonathanschilling.github.io/labathome.de/elektrotechnik/transputer/avm_t1/" class="">AVM T1</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://jonathanschilling.github.io/labathome.de/elektrotechnik/leonardo_xl/" class="">Leonardo XL PCI</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-2c2643383fea6fada6fc27dbe97de8e4" class="toggle"  />
    <label for="section-2c2643383fea6fada6fc27dbe97de8e4" class="flex justify-between">
      <a  class="">Mechanical Engineering</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://jonathanschilling.github.io/labathome.de/maschinenbau/deckel_fp1/" class="">Deckel FP1</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://jonathanschilling.github.io/labathome.de/maschinenbau/dlz180x450/" class="">Saupe DLZ180x450</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://jonathanschilling.github.io/labathome.de/maschinenbau/kleine_drehbank/" class="">Small Tabletop Lathe</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://jonathanschilling.github.io/labathome.de/maschinenbau/gys_protig/" class="">GYS PROTIG 201 AC/DC</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://jonathanschilling.github.io/labathome.de/maschinenbau/klopp_550/" class="">Klopp 550</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://jonathanschilling.github.io/labathome.de/maschinenbau/tiboma_bm6/" class="">Johannes Tittel BM6</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://jonathanschilling.github.io/labathome.de/maschinenbau/tooling/" class="">Maschinenzubehör</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-ab610fcdf9409e4ed411cb3c34fcb85a" class="toggle" checked />
    <label for="section-ab610fcdf9409e4ed411cb3c34fcb85a" class="flex justify-between">
      <a  class="">Numerics</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://jonathanschilling.github.io/labathome.de/numerics/fftw_tutorial/" class=" active">FFTW Tutorial</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-e7cfe3d2127c77d408f29ad616291b1e" class="toggle"  />
    <label for="section-e7cfe3d2127c77d408f29ad616291b1e" class="flex justify-between">
      <a  class="">Physics</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://jonathanschilling.github.io/labathome.de/physics/TVP250/" class="">Pfeiffer TVP250</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://jonathanschilling.github.io/labathome.de/physics/kf40_cf40/" class="">Adapterflansche KF40/CF40</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://jonathanschilling.github.io/labathome.de/about/" class="">About this website</a>
  

        </li>
      
    
  </ul>















</nav>




  <script>(function(){var e=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>


 
      </div>
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/labathome.de/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <strong>FFTW Tutorial</strong>

  <label for="toc-control">
    
    <img src="/labathome.de/svg/toc.svg" class="book-icon" alt="Table of Contents" />
    
  </label>
</div>


  
  <aside class="hidden clearfix">
    
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#one-dimensional-examples">One-Dimensional Examples</a>
      <ul>
        <li><a href="#1d-complex-to-complex">1D complex-to-complex</a></li>
        <li><a href="#1d-complex-to-real-and-real-to-complex">1D complex-to-real and real-to-complex</a></li>
        <li><a href="#1d-real-to-real">1D real-to-real</a></li>
      </ul>
    </li>
    <li><a href="#two-dimensional-examples">Two-Dimensional Examples</a>
      <ul>
        <li><a href="#2d-complex-to-complex">2D complex-to-complex</a></li>
        <li><a href="#2d-complex-to-real">2D complex-to-real</a></li>
        <li><a href="#2d-real-to-complex">2D real-to-complex</a></li>
        <li><a href="#2d-real-to-real">2D real-to-real</a></li>
      </ul>
    </li>
    <li><a href="#real-world-applications">Real-world applications</a>
      <ul>
        <li><a href="#geometry-of-the-magnetic-axis-in-a-stellarator">Geometry of the Magnetic Axis in a Stellarator</a></li>
        <li><a href="#geometry-of-a-flux-surface-in-a-stellarator">Geometry of a Flux Surface in a Stellarator</a></li>
      </ul>
    </li>
    <li><a href="#allocation-of-arrays">Allocation of arrays</a></li>
    <li><a href="#utility-functions">Utility functions</a></li>
  </ul>
</nav>



  </aside>
  
 
      </header>

      
      
  <article class="markdown"><h1 id="fftw-tutorial">
  FFTW Tutorial
  <a class="anchor" href="#fftw-tutorial">#</a>
</h1>
<p>This is a basic C project (Makefile, but also for the Eclipse IDE) I use for exploring FFTW 3.3.9.</p>
<p>One- and two-dimensional discrete Fourier transforms (DFTs) of random data are computed using both FFTW and straight-forward naive algorithms
in order to illustrate explicitly what kind of symmetries and scaling properties FFTW implies in its inputs and outputs.</p>
<h2 id="one-dimensional-examples">
  One-Dimensional Examples
  <a class="anchor" href="#one-dimensional-examples">#</a>
</h2>
<p>This tutorial starts by computing one-dimensional (1D) DFTs of random input data.</p>
<h3 id="1d-complex-to-complex">
  1D complex-to-complex
  <a class="anchor" href="#1d-complex-to-complex">#</a>
</h3>
<p>The first example is basically a self-contained version
of the <a href="http://fftw.org/fftw3_doc/Complex-One_002dDimensional-DFTs.html#Complex-One_002dDimensional-DFTs">corresponding example in the FFTW manual</a>.</p>
<p>We want to compute the complex-valued one-dimensional DFT here, which is specified in
<a href="http://fftw.org/fftw3_doc/The-1d-Discrete-Fourier-Transform-_0028DFT_0029.html#The-1d-Discrete-Fourier-Transform-_0028DFT_0029">section 4.8.1 of the FFTW reference manual</a>.</p>
<p><!-- raw HTML omitted -->$$
Y_k = \sum\limits_{j=0}^{n-1} X_j \, e^{\pm 2 \pi j k \sqrt{-1}/n} \textrm{ for } k=0,1,&hellip;,(n-1)
$$<!-- raw HTML omitted --></p>
<p>The sign in the exponent of the basis function specifies the direction in which the Fourier transform is to be computed:
<code>-1</code> indicates a &ldquo;forward&rdquo; transform and <code>+1</code> indicates a &ldquo;backward&rdquo; transform.
These values are available via the <code>FFTW_FORWARD</code> and <code>FFTW_BACKWARD</code> preprocessor macros.</p>
<p>In order to compute the DFT, complex-valued products of the following form need to be evaluated:</p>
<p><!-- raw HTML omitted -->$$
X_j \, e^{\pm 2 \pi j k \sqrt{-1}/n}
$$<!-- raw HTML omitted --></p>
<p>Eulers formula comes in handy now (where <!-- raw HTML omitted -->$i$<!-- raw HTML omitted --> is the imaginary unit with <!-- raw HTML omitted -->${i}^2=-1$<!-- raw HTML omitted -->):</p>
<p><!-- raw HTML omitted -->$$
e^{i \varphi} = \cos(\varphi) + i \sin(\varphi)
$$<!-- raw HTML omitted --></p>
<p>The angle argument <code>phi</code> can be identified in above formulas for the DFT:</p>
<p><!-- raw HTML omitted -->$$
\varphi = \pm 2 \pi j k / n
$$<!-- raw HTML omitted --></p>
<p>Now the complex-valued product can be computed using only real-valued variables:</p>
<p><!-- raw HTML omitted -->\begin{align}
~&amp; \left( \mathcal{Re}(X_j) + i \, \mathcal{Im}(X_j) \right) \cdot \left( \cos(\varphi) + i \sin(\varphi) \right) \\
=&amp; \phantom{+ i}~ \left( \mathcal{Re}(X_j) \cos(\varphi) - \mathcal{Im}(X_j) \sin(\varphi) \right) \\
~&amp;          + i   \left( \mathcal{Re}(X_j) \sin(\varphi) + \mathcal{Im}(X_j) \cos(\varphi) \right)
\end{align}<!-- raw HTML omitted --></p>
<p>FFTW implements all this math internally and the explicit formulation was only used to build a basis for the computations to follow.
Below is the example code showing how to compute the 1d <code>c2c</code> DFT using both FFTW and a manual implementation.
The size of the DFT is specified via the variable <code>n</code> and the direction (forward or backward) is specified via the variable <code>dir</code>.
Complex-valued arrays <code>in</code>, <code>ref_out</code> and <code>fftw_out</code> are allocated to hold the input (<em>X_k</em>) and outputs (<em>Y_k</em>) of the DFT.
A plan for the corresponding DFT is created using <code>fftw_plan_dft_1d</code>.
Only after this, the input data is written into the <code>in</code> array.
The reference output is computed now (before calling <code>fftw_execute</code>), since in some later examples (most notably multi-dimensional <code>c2r</code> transforms),
FFTW overwrites the input data and for good practise, we keep this in mind already now.
Note that this is an out-of-place transform, since <code>in</code> and <code>fftw_out</code> are allocated to be separate arrays.
Next the FFTW transform can be executed via <code>fftw_execute</code>.
This fills the corresponding output array <code>fftw_out</code>, which is subsequently compared against the reference output in <code>ref_out</code>.
A conservative tolerance of <code>1e-12</code> is specified to make the example work also for weird input data (as generated by the PRNG).
The actual deviations are usually much smaller and can be observed in the screen output from <code>compare_1d_cplx</code>.
Finally, the <code>fftw_plan</code> is destroyed and the memory is released using <code>fftw_free</code> (which has to be used if the array was allocated using <code>fftw_alloc_*</code>).</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;math.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;complex.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;fftw3.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;util.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">test_1d_c2c</span>(<span style="color:#66d9ef">int</span> n) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> dir <span style="color:#f92672">=</span> FFTW_BACKWARD;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">double</span> real, imag, phi;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    fftw_complex <span style="color:#f92672">*</span>in <span style="color:#f92672">=</span> fftw_alloc_complex(n);
</span></span><span style="display:flex;"><span>    fftw_complex <span style="color:#f92672">*</span>ref_out <span style="color:#f92672">=</span> fftw_alloc_complex(n);
</span></span><span style="display:flex;"><span>    fftw_complex <span style="color:#f92672">*</span>fftw_out <span style="color:#f92672">=</span> fftw_alloc_complex(n);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    fftw_plan p <span style="color:#f92672">=</span> fftw_plan_dft_1d(n, in, fftw_out, dir, FFTW_ESTIMATE);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// fill the input array with random data
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    fill_random_1d_cplx(n, in);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// compute the reference output
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> k <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; k <span style="color:#f92672">&lt;</span> n; <span style="color:#f92672">++</span>k) {
</span></span><span style="display:flex;"><span>        ref_out[k] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;</span> n; <span style="color:#f92672">++</span>j) {
</span></span><span style="display:flex;"><span>            phi <span style="color:#f92672">=</span> dir <span style="color:#f92672">*</span> <span style="color:#ae81ff">2.0</span> <span style="color:#f92672">*</span> M_PI <span style="color:#f92672">*</span> j <span style="color:#f92672">*</span> k <span style="color:#f92672">/</span> ((<span style="color:#66d9ef">double</span>) n);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            real <span style="color:#f92672">=</span> creal(in[j]) <span style="color:#f92672">*</span> cos(phi) <span style="color:#f92672">-</span> cimag(in[j]) <span style="color:#f92672">*</span> sin(phi);
</span></span><span style="display:flex;"><span>            imag <span style="color:#f92672">=</span> creal(in[j]) <span style="color:#f92672">*</span> sin(phi) <span style="color:#f92672">+</span> cimag(in[j]) <span style="color:#f92672">*</span> cos(phi);
</span></span><span style="display:flex;"><span>            ref_out[k] <span style="color:#f92672">+=</span> real <span style="color:#f92672">+</span> I <span style="color:#f92672">*</span> imag;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// compute the DFT of in using FFTW
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    fftw_execute(p);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// compare reference output with FFTW output
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">double</span> eps <span style="color:#f92672">=</span> <span style="color:#ae81ff">1e-12</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> status <span style="color:#f92672">=</span> compare_1d_cplx(n, ref_out, fftw_out, eps);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    fftw_destroy_plan(p);
</span></span><span style="display:flex;"><span>    fftw_free(in);
</span></span><span style="display:flex;"><span>    fftw_free(ref_out);
</span></span><span style="display:flex;"><span>    fftw_free(fftw_out);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> status;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span><span style="color:#f92672">**</span> argv) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> status <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    status <span style="color:#f92672">+=</span> test_1d_c2c(<span style="color:#ae81ff">32</span>);
</span></span><span style="display:flex;"><span>    status <span style="color:#f92672">+=</span> test_1d_c2c(<span style="color:#ae81ff">33</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> status;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The code is available in the file <a href="src/test_1d_c2c.c"><code>src/test_1d_c2c.c</code></a>.</p>
<h3 id="1d-complex-to-real-and-real-to-complex">
  1D complex-to-real and real-to-complex
  <a class="anchor" href="#1d-complex-to-real-and-real-to-complex">#</a>
</h3>
<p>The next two examples deal with DFTs of purely real data (<code>r2c</code>) and DFTs which <em>produce</em> purely real data (<code>c2r</code>).
These are covered in the <a href="http://fftw.org/fftw3_doc/One_002dDimensional-DFTs-of-Real-Data.html#One_002dDimensional-DFTs-of-Real-Data">official FFTW tutorial</a>
as well as in the <a href="http://fftw.org/fftw3_doc/The-1d-Real_002ddata-DFT.html#The-1d-Real_002ddata-DFT">FFTW reference manual</a>.</p>
<p>In case either the input array or the output array are constrained to be purely real, the corresponding complex-valued output or input array
features Hermitian symmetry (where the <code>n</code>-periodicity has been included as well):</p>
<p><!-- raw HTML omitted -->$$
Y_{n-k} = Y_{-k} = Y^{*}_k
$$<!-- raw HTML omitted --></p>
<p>For the case of a DFT of real-valued <em>X_j</em> and complex-valued <em>Y_k</em> with Hermitian symmetry,
the Fourier sum is written out excplicitly as follows:</p>
<p><!-- raw HTML omitted -->$$\begin{align}
%TODO: fix underbrace
Y_{-k} =&amp; \sum\limits_{j=0}^{n-1} X_j \Bigl(    \cos(-2 \pi j k / n)
+ i \sin(-2 \pi j k / n) \Bigr) \\
=&amp; \sum\limits_{j=0}^{n-1} X_j \Bigl( \cos(2 \pi j k / n) - i \sin(2 \pi j k / n) \Bigr) = Y^{*}_k
\end{align}$$<!-- raw HTML omitted --></p>
<p>The figure below illustrates the structure of the complex-valued Fourier space arrays
occuring in the DFT for both even-valued (<code>n=6</code>) and odd-valued (<code>n=7</code>) sizes of the DFT.</p>
<p><img src="img/array_structures.png" alt="array structure" /></p>
<p>The size required to contain all information required for the transform from or to a real-valued array
is contained in the first <code>n/2+1</code> (division by 2 rounded down) entries of the complex array, indicated by the red bars in above figure.
For both even and odd values of <code>n</code>, Hermitian symmetry implies <em>Y_0</em> = <em>Y*_0</em> and thus <em>Y_0</em> is always real.
In the case of even <code>n</code>, we can intuitively observe that <em>Y_m</em> = <em>Y*_-m</em> where <em>m</em>=<code>n/2</code> (the element at the Nyquist frequency,
and thus also the last element of the complex-valued Fourier-space array) is also purely real.</p>
<p>The DFT formulation includes all elements of the Fourier-space array from 0 to <code>n-1</code>.
Now that only parts of these coefficients are taken into account, they have to be weighted appropriately
to recover the results that would have been obtained by using the full array without taking advantage of its symmetry properties.
For odd <code>n</code>, all components of the Fourier-space array except the DC element at <em>k</em>=0 have to be weighted with a factor of 2.
For even <code>n</code>, all components of the Fourier-space array except the DC element at <em>k</em>=0 and the Nyquist element at <em>k</em>=<code>n/2</code>
have to be weighted with a factor of 2.
The elements that need to be weighted by a factor of 2 are highlighted by solid blue lines in above illustration.
The redundant elements that are not explicitly needed are indicated by dashed blue lines.</p>
<p>The backward transformation from complex-valued Fourier space
to real space is demonstrated in <a href="src/test_1d_c2r.c"><code>src/test_1d_c2r.c</code></a>.
The relevant portion of the source code is here:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> nCplx <span style="color:#f92672">=</span> n <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> k <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; k <span style="color:#f92672">&lt;</span> n; <span style="color:#f92672">++</span>k) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// start with DC component, which is purely real due to Hermitian symmetry
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    ref_out[k] <span style="color:#f92672">=</span> creal(in[<span style="color:#ae81ff">0</span>]);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> loopEnd <span style="color:#f92672">=</span> nCplx;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// special case for even n
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (n <span style="color:#f92672">%</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Nyquist element is purely real as well
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        phi <span style="color:#f92672">=</span> <span style="color:#ae81ff">2.0</span> <span style="color:#f92672">*</span> M_PI <span style="color:#f92672">*</span> (nCplx <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">*</span> k <span style="color:#f92672">/</span> ((<span style="color:#66d9ef">double</span>) n);
</span></span><span style="display:flex;"><span>        ref_out[k] <span style="color:#f92672">+=</span> creal(in[nCplx <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>]) <span style="color:#f92672">*</span> cos(phi);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        loopEnd <span style="color:#f92672">=</span> nCplx<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// middle elements are handled the same for even and odd n
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; j <span style="color:#f92672">&lt;</span> loopEnd; <span style="color:#f92672">++</span>j) {
</span></span><span style="display:flex;"><span>        phi <span style="color:#f92672">=</span> <span style="color:#ae81ff">2.0</span> <span style="color:#f92672">*</span> M_PI <span style="color:#f92672">*</span> j <span style="color:#f92672">*</span> k <span style="color:#f92672">/</span> ((<span style="color:#66d9ef">double</span>) n);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        real <span style="color:#f92672">=</span> creal(in[j]) <span style="color:#f92672">*</span> cos(phi) <span style="color:#f92672">-</span> cimag(in[j]) <span style="color:#f92672">*</span> sin(phi);
</span></span><span style="display:flex;"><span>        ref_out[k] <span style="color:#f92672">+=</span> <span style="color:#ae81ff">2.0</span> <span style="color:#f92672">*</span> real;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Note that the integer division used to compute <code>nCplx</code> (correctly) rounds down.
The rest is a relatively straight-forward implementation of above verbose algorithm.
The DC component is always taken to be real.
Depending on whether <code>n</code> is even or odd, the number of elements to take into account with both real and imaginary component (<code>loopEnd</code>) is adjusted.
The (purely real) Nyquist element at <code>n/2</code> is added separately if <code>n</code> is even.
All other elements are weighted by a factor of 2 and only the real part
of the complex product of input Fourier coefficient and complex-valued basis function is actually computed.</p>
<p>The forward transform from real space to Fourier space is comparably simple to implement:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> k <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; k <span style="color:#f92672">&lt;</span> nCplx; <span style="color:#f92672">++</span>k) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// DC component is always real
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    ref_out[k] <span style="color:#f92672">=</span> in[<span style="color:#ae81ff">0</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; j <span style="color:#f92672">&lt;</span> n; <span style="color:#f92672">++</span>j) {
</span></span><span style="display:flex;"><span>        phi <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">2.0</span> <span style="color:#f92672">*</span> M_PI <span style="color:#f92672">*</span> j <span style="color:#f92672">*</span> k <span style="color:#f92672">/</span> ((<span style="color:#66d9ef">double</span>) n);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        real <span style="color:#f92672">=</span> in[j] <span style="color:#f92672">*</span> cos(phi);
</span></span><span style="display:flex;"><span>        imag <span style="color:#f92672">=</span> in[j] <span style="color:#f92672">*</span> sin(phi);
</span></span><span style="display:flex;"><span>        ref_out[k] <span style="color:#f92672">+=</span> real <span style="color:#f92672">+</span> I <span style="color:#f92672">*</span> imag;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Note that in this case, only the non-redundant part of the complex-values Fourier coefficients need to be computed
from a real-valued input. The separate handling of the DC component is not strictly necessary, since <code>cos(0)=1</code> and <code>sin(0)=0</code>
and thus the DC component would get no imaginary contribution.
The full example is available in the file <a href="src/test_1d_r2c.c"><code>src/test_1d_r2c.c</code></a>.</p>
<p>It becomes evident in above examples that the sign of a <code>c2r</code> DFT is always <code>FFTW_BACKWARD</code> and
the sign of a <code>r2c</code> DFT is always <code>FFTW_FORWARD</code>.</p>
<h3 id="1d-real-to-real">
  1D real-to-real
  <a class="anchor" href="#1d-real-to-real">#</a>
</h3>
<p>Certain symmetries can be assumed for a given real input array of which a DFT is to be computed
that lead to the output array being purely real as well. This is another gain of a factor of 2 in speed
and memory usage over <code>r2c</code>/<code>c2r</code> transforms.
Depending on even (odd) parity of the input array, the transform outputs have even (odd) parity.
They are therefore called Discrete Cosine Transform (DCT) and Discrete Sine Transfrom (DST), respectively.</p>
<p>The logical size of the corresponding DFT is denoted as <em>N</em>.
The actual array size given to FFTW is denoted by <code>n</code>.
For the DCT/DST types implemented in FFTW, <em>N</em> is always even.
Note that this does not pose any restrictions on the input array sizes <code>n</code>.
One can think of the logical DFT input array as one that FFTW &lsquo;sees&rsquo; internally and computes a regular DFT of.
The resulting output array is purely real and features the named symmetry properties,
since the logical input array was &lsquo;constructed&rsquo; from the given input array to have the desired symmetry properties.</p>
<p>In below example plots used to illustrate these symmetry properties/assumptions,
random Fourier coefficients have been sampled and transformed back to real-space using the named inverse transforms.
This allows to &rsquo;evaluate&rsquo; the input data also in the samples given in the (small) input arrays.
In these plots, red dashed vertical lines indicate even symmetry (<em>f(x)=f(-x)</em>) about the indicated position
and blue dashed vertical lines indicate odd symmetry (<em>f(x)=-f(-x)</em>) about the indicated position.
The grey-shaded area in the background indicated the range of samples that are included in the input array.
The x axis labels denote the indices in the actual input array given to FFTW (only valid within the range of the grey boxes).</p>
<p>The nomenclature works as follows:
The first letter is <strong>R</strong> to indicate real-valued data.
The second letter distinguished between <strong>E</strong> for even-parity data and <strong>O</strong> for odd-parity data.
The following <strong>DFT</strong> is for discrete Fourier transform (who guessed&hellip;).
The next two digits indicate wheter (<strong>1</strong>) or not (<strong>0</strong>) the input (first digit) or the output (second digit) data is shifted by half a sample.
Think of this in terms of parity: whether the symmetry axis is located at a sample (no shifting necessary) or between two samples (shifting necessary).
The shifting becomes necessary when formulating the symmetry properties over sampled data that has integer indices
vs. symmetry axis that are possibly located at half-integer locations.
The parity and symmetry properties of the output array are those of the input array for the inverse transform.</p>
<p>For all transforms, a periodicity of <em>N</em> is assumed for the <em>logical</em> input array as <em>X_j = X_{N+j}</em> where <em>X</em> is the input data array.</p>
<p>Here is a quick overview table to indicate the assumed symmetries in the input array for the following types of <code>r2r</code> DFTs:</p>
<table>
<thead>
<tr>
<th style="text-align:center">type</th>
<th style="text-align:center">actual <code>r2r</code> input</th>
<th style="text-align:center">logically-equivalent DFT input</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">REDFT00</td>
<td style="text-align:center"><code>a b c d e</code></td>
<td style="text-align:center"><code>a b c d  e  d  c  b</code></td>
</tr>
<tr>
<td style="text-align:center">REDFT10</td>
<td style="text-align:center"><code>a b c d  </code></td>
<td style="text-align:center"><code>a b c d  d  c  b  a</code></td>
</tr>
<tr>
<td style="text-align:center">REDFT01</td>
<td style="text-align:center"><code>a b c d  </code></td>
<td style="text-align:center"><code>a b c d  0 -d -c -b</code></td>
</tr>
<tr>
<td style="text-align:center">REDFT11</td>
<td style="text-align:center"><code>a b c d  </code></td>
<td style="text-align:center"><code>a b c d -d -c -b -a</code></td>
</tr>
<tr>
<td style="text-align:center">RODFT00</td>
<td style="text-align:center"><code>a b c    </code></td>
<td style="text-align:center"><code>0 a b c  0 -c -b -a</code></td>
</tr>
<tr>
<td style="text-align:center">RODFT10</td>
<td style="text-align:center"><code>a b c d  </code></td>
<td style="text-align:center"><code>a b c d -d -c -b -a</code></td>
</tr>
<tr>
<td style="text-align:center">RODFT01</td>
<td style="text-align:center"><code>a b c d  </code></td>
<td style="text-align:center"><code>a b c d  c  b  a  0</code></td>
</tr>
<tr>
<td style="text-align:center">RODFT11</td>
<td style="text-align:center"><code>a b c d  </code></td>
<td style="text-align:center"><code>a b c d  d  c  b  a</code></td>
</tr>
</tbody>
</table>
<p>For the DCTs, please also consider <a href="https://en.wikipedia.org/wiki/Discrete_cosine_transform#Formal_definition">https://en.wikipedia.org/wiki/Discrete_cosine_transform#Formal_definition</a>
and in particular <a href="https://upload.wikimedia.org/wikipedia/commons/a/ae/DCT-symmetries.svg">https://upload.wikimedia.org/wikipedia/commons/a/ae/DCT-symmetries.svg</a> .</p>
<p>For the DSTs, please also consider <a href="https://en.wikipedia.org/wiki/Discrete_sine_transform#Definition">https://en.wikipedia.org/wiki/Discrete_sine_transform#Definition</a>
and in particular <a href="https://upload.wikimedia.org/wikipedia/commons/3/31/DST-symmetries.svg">https://upload.wikimedia.org/wikipedia/commons/3/31/DST-symmetries.svg</a> .</p>
<h4 id="redft00-dct-i">
  REDFT00 (DCT-I)
  <a class="anchor" href="#redft00-dct-i">#</a>
</h4>
<p>In case of the real-valued even-parity DFT with no shifts in either input or output array (REDFT00),
also called the DCT-I, the corresponding logical DFT size is given by <em>N</em> = 2(<code>n</code>-1), corresponding to <code>n</code> = <em>N</em>/2+1.</p>
<p>The formal definition of the REDFT00 is given below:</p>
<p><!-- raw HTML omitted -->$$</p>
<p>$$<!-- raw HTML omitted -->
<img src="eqn/redft00.png" alt="REDFT00 formula" /></p>
<p>The inverse of this transform is REDFT00 itself.
The input array is assumed to have even symmetry around <em>j=0</em> and even symmetry also around <em>j=n−1</em>.</p>
<p><img src="img/redft00.png" alt="REDFT00" /></p>
<p>In above figure, the lowercase letters <em>a</em> to <em>e</em> refer to the input data <em>abcde</em> for the size-5 REDFT00,
which is logically equivalent to a size-8 DFT with real-valued input data <em>abcdedcb</em>.</p>
<p>In order to demonstrate the use of this method,
the logically equivalent DFT input is filled appropriately and its output is checked against <code>REDFT00</code>.
In the following code, <code>in</code> is the input array (size <code>n</code>) given to <code>REDFT00</code>
and <code>in_logical</code> is the (complex-valued) input array (size <em>N</em>) handed to a
<a href="https://en.wikipedia.org/wiki/Discrete_Fourier_transform#Generalized_DFT_%28shifted_and_non-linear_phase%29">generic 1D DFT</a>.
Similarly, <code>out</code> is the output array (size <code>n</code>) from <code>REDFT00</code>
and <code>out_logical</code> is the output array (size <em>N</em>) from a generic 1D DFT.</p>
<p>Here is how the symmetric input is generated:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#75715e">// the first half of the array is identical
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; i<span style="color:#f92672">&lt;</span>n; <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>    in_logical[i] <span style="color:#f92672">=</span> in[i];
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// second half is filled according to even symmetry around n-1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; i<span style="color:#f92672">&lt;</span>n<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>; <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>    in_logical[n<span style="color:#f92672">+</span>i] <span style="color:#f92672">=</span> in[n<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span><span style="color:#f92672">-</span>i];
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The checks are a little bit more involved.
The logically equivalent DFT output should be purely real-valued:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> N; <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (fabs(cimag(out_logical[i])) <span style="color:#f92672">&gt;</span> eps) {
</span></span><span style="display:flex;"><span>        printf(<span style="color:#e6db74">&#34;error: imag of [%d] is %g</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, i, cimag(out_logical[i]));
</span></span><span style="display:flex;"><span>        status <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        printf(<span style="color:#e6db74">&#34;imag of [%d] is %g</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, i, cimag(out_logical[i]));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The first <code>n</code> values should be identical between <code>REDFT00</code> and the generalized DFT:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">double</span> delta;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>    delta <span style="color:#f92672">=</span> creal(out_logical[i]) <span style="color:#f92672">-</span> out[i];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (fabs(delta) <span style="color:#f92672">&gt;</span> eps) {
</span></span><span style="display:flex;"><span>        printf(<span style="color:#e6db74">&#34;error: delta of [%d] is %g</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, i, delta);
</span></span><span style="display:flex;"><span>        status <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        printf(<span style="color:#e6db74">&#34;match of [%d] (delta=%g)</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, i, delta);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The remaining values should have even symmetry around <code>n-1</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n <span style="color:#f92672">-</span> <span style="color:#ae81ff">2</span>; <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>    delta <span style="color:#f92672">=</span> creal(out_logical[n <span style="color:#f92672">+</span> i]) <span style="color:#f92672">-</span> out[n <span style="color:#f92672">-</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">-</span> i];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (fabs(delta) <span style="color:#f92672">&gt;</span> eps) {
</span></span><span style="display:flex;"><span>        printf(<span style="color:#e6db74">&#34;error: delta of [%d] is %g</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, n<span style="color:#f92672">+</span>i, delta);
</span></span><span style="display:flex;"><span>        status <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        printf(<span style="color:#e6db74">&#34;match of [%d] (delta=%g)</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, n<span style="color:#f92672">+</span>i, delta);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The full example can be found in <a href="src/test_1d_redft00.c"><code>src/test_1d_redft00.c</code></a>.</p>
<h4 id="redft10-dct-ii">
  REDFT10 (DCT-II)
  <a class="anchor" href="#redft10-dct-ii">#</a>
</h4>
<p>In case of the real-valued even-parity DFT with shifted input data (REDFT10),
also called the DCT-II, the corresponding logical DFT size is given by <em>N</em> = 2<code>n</code>, corresponding to <code>n</code> = <em>N</em>/2.
This function is commonly known as &ldquo;the&rdquo; DCT.</p>
<p>The formal definition of the REDFT10 is given below:</p>
<p><!-- raw HTML omitted -->$$</p>
<p>$$<!-- raw HTML omitted -->
<img src="eqn/redft10.png" alt="REDFT10 formula" /></p>
<p>The inverse of this transform is REDFT01.
The input array is assumed to have even symmetry around <em>j=-0.5</em> and even symmetry also around <em>j=n−0.5</em>.</p>
<p><img src="img/redft10.png" alt="REDFT10" /></p>
<p>In above figure, the lowercase letters <em>a</em> to <em>e</em> refer to the input data <em>abcd</em> for the size-4 REDFT10,
which is logically equivalent to a size-8 DFT with real-valued input data <em>abcddcba</em>.</p>
<p>In order to demonstrate the use of this method,
the logically equivalent DFT input is filled appropriately and its output is checked against <code>REDFT10</code>.
In the following code, <code>in</code> is the input array (size <code>n</code>) given to <code>REDFT10</code>
and <code>in_logical</code> is the (complex-valued) input array (size <em>N</em>) handed to a
<a href="https://en.wikipedia.org/wiki/Discrete_Fourier_transform#Generalized_DFT_%28shifted_and_non-linear_phase%29">generic 1D DFT</a>.
Similarly, <code>out</code> is the output array (size <code>n</code>) from <code>REDFT10</code>
and <code>out_logical</code> is the output array (size <em>N</em>) from a generic 1D DFT.</p>
<p>Here is how the symmetric input is generated:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#75715e">// the first half of the array is identical
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>    in_logical[i] <span style="color:#f92672">=</span> in[i];
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// second half is filled according to even symmetry around n-0.5
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>    in_logical[n <span style="color:#f92672">+</span> i] <span style="color:#f92672">=</span> in[n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">-</span> i];
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The checks are a little bit more involved.
The logically equivalent DFT output should be purely real-valued:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> N; <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (fabs(cimag(out_logical[i])) <span style="color:#f92672">&gt;</span> eps) {
</span></span><span style="display:flex;"><span>        printf(<span style="color:#e6db74">&#34;error: imag of [%d] is %g</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, i, cimag(out_logical[i]));
</span></span><span style="display:flex;"><span>        status <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        printf(<span style="color:#e6db74">&#34;imag of [%d] is %g</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, i, cimag(out_logical[i]));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The first <code>n</code> values should be identical between <code>REDFT10</code> and the generalized DFT:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>    delta <span style="color:#f92672">=</span> creal(out_logical[i]) <span style="color:#f92672">-</span> out[i];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (fabs(delta) <span style="color:#f92672">&gt;</span> eps) {
</span></span><span style="display:flex;"><span>        printf(<span style="color:#e6db74">&#34;error: delta of [%d] is %g</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, i, delta);
</span></span><span style="display:flex;"><span>        status <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        printf(<span style="color:#e6db74">&#34;match of [%d] (delta=%g)</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, i, delta);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Odd symmetry around <code>n</code> implies that the value at <code>n</code> is zero:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (fabs(creal(out_logical[n])) <span style="color:#f92672">&gt;</span> eps) {
</span></span><span style="display:flex;"><span>    printf(<span style="color:#e6db74">&#34;error: delta of [%d] is %g</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, n, creal(out_logical[n]));
</span></span><span style="display:flex;"><span>    status <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>    printf(<span style="color:#e6db74">&#34;match of [%d] (delta=%g)</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, n, creal(out_logical[n]));
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The remaining values should have odd symmetry around <code>n</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span> n; <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>    delta <span style="color:#f92672">=</span> creal(out_logical[n <span style="color:#f92672">+</span> i]) <span style="color:#f92672">-</span> (<span style="color:#f92672">-</span>out[n <span style="color:#f92672">-</span> i]);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (fabs(delta) <span style="color:#f92672">&gt;</span> eps) {
</span></span><span style="display:flex;"><span>        printf(<span style="color:#e6db74">&#34;error: delta of [%d] is %g</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, n <span style="color:#f92672">+</span> i, delta);
</span></span><span style="display:flex;"><span>        status <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        printf(<span style="color:#e6db74">&#34;match of [%d] (delta=%g)</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, n <span style="color:#f92672">+</span> i, delta);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The full example can be found in <a href="src/test_1d_redft10.c"><code>src/test_1d_redft10.c</code></a>.</p>
<h4 id="redft01-dct-iii">
  REDFT01 (DCT-III)
  <a class="anchor" href="#redft01-dct-iii">#</a>
</h4>
<p>In case of the real-valued even-parity DFT with shifted output data (REDFT01),
also called the DCT-III, the corresponding logical DFT size is given by <em>N</em> = 2<code>n</code>, corresponding to <code>n</code> = <em>N</em>/2.
This function is commonly known as &ldquo;the&rdquo; inverse DCT (IDCT).</p>
<p>The formal definition of the REDFT01 is given below:</p>
<p><!-- raw HTML omitted -->$$</p>
<p>$$<!-- raw HTML omitted -->
<img src="eqn/redft01.png" alt="REDFT01 formula" /></p>
<p>The inverse of this transform is REDFT10.
The input array is assumed to have even symmetry around <em>j=0</em> and odd symmetry around <em>j=n</em>.</p>
<p><img src="img/redft01.png" alt="REDFT01" /></p>
<p>In order to demonstrate the use of this method,
the logically equivalent DFT input is filled appropriately and its output is checked against <code>REDFT01</code>.
In the following code, <code>in</code> is the input array (size <code>n</code>) given to <code>REDFT01</code>
and <code>in_logical</code> is the (complex-valued) input array (size <em>N</em>) handed to a
<a href="https://en.wikipedia.org/wiki/Discrete_Fourier_transform#Generalized_DFT_%28shifted_and_non-linear_phase%29">generic 1D DFT</a>.
Similarly, <code>out</code> is the output array (size <code>n</code>) from <code>REDFT01</code>
and <code>out_logical</code> is the output array (size <em>N</em>) from a generic 1D DFT.</p>
<p>Here is how the symmetric input is generated:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#75715e">// the first half of the array is identical
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>    in_logical[i] <span style="color:#f92672">=</span> in[i];
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// second half is filled according to odd symmetry around n
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span> n; <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>    in_logical[n <span style="color:#f92672">+</span> i] <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>in[n <span style="color:#f92672">-</span> i];
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The checks are a little bit more involved.
The logically equivalent DFT output should be purely real-valued:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> N; <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (fabs(cimag(out_logical[i])) <span style="color:#f92672">&gt;</span> eps) {
</span></span><span style="display:flex;"><span>        printf(<span style="color:#e6db74">&#34;error: imag of [%d] is %g</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, i, cimag(out_logical[i]));
</span></span><span style="display:flex;"><span>        status <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        printf(<span style="color:#e6db74">&#34;imag of [%d] is %g</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, i, cimag(out_logical[i]));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The first <code>n</code> values should be identical between <code>REDFT01</code> and the generalized DFT:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>    delta <span style="color:#f92672">=</span> creal(out_logical[i]) <span style="color:#f92672">-</span> out[i];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (fabs(delta) <span style="color:#f92672">&gt;</span> eps) {
</span></span><span style="display:flex;"><span>        printf(<span style="color:#e6db74">&#34;error: delta of [%d] is %g</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, i, delta);
</span></span><span style="display:flex;"><span>        status <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        printf(<span style="color:#e6db74">&#34;match of [%d] (delta=%g)</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, i, delta);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The remaining values should have even symmetry around <code>n-0.5</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>    delta <span style="color:#f92672">=</span> creal(out_logical[n <span style="color:#f92672">+</span> i]) <span style="color:#f92672">-</span> out[n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">-</span> i];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (fabs(delta) <span style="color:#f92672">&gt;</span> eps) {
</span></span><span style="display:flex;"><span>        printf(<span style="color:#e6db74">&#34;error: delta of [%d] is %g</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, n <span style="color:#f92672">+</span> i, delta);
</span></span><span style="display:flex;"><span>        status <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        printf(<span style="color:#e6db74">&#34;match of [%d] (delta=%g)</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, n <span style="color:#f92672">+</span> i, delta);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The full example can be found in <a href="src/test_1d_redft01.c"><code>src/test_1d_redft01.c</code></a>.</p>
<h4 id="redft11-dct-iv">
  REDFT11 (DCT-IV)
  <a class="anchor" href="#redft11-dct-iv">#</a>
</h4>
<p>In case of the real-valued even-parity DFT with both shifted input and output data (REDFT11),
also called the DCT-IV, the corresponding logical DFT size is given by <em>N</em> = 2<code>n</code>, corresponding to <code>n</code> = <em>N</em>/2.</p>
<p>The formal definition of the REDFT11 is given below:</p>
<p><!-- raw HTML omitted -->$$</p>
<p>$$<!-- raw HTML omitted -->
<img src="eqn/redft11.png" alt="REDFT11 formula" /></p>
<p>The inverse of this transform is REDFT11 itself.
The input array is assumed to have even symmetry around <em>j=-0.5</em> and odd symmetry around <em>j=n-0.5</em>.</p>
<p><img src="img/redft11.png" alt="REDFT11" /></p>
<p>In order to demonstrate the use of this method,
the logically equivalent DFT input is filled appropriately and its output is checked against <code>REDFT11</code>.
In the following code, <code>in</code> is the input array (size <code>n</code>) given to <code>REDFT11</code>
and <code>in_logical</code> is the (complex-valued) input array (size <em>N</em>) handed to a
<a href="https://en.wikipedia.org/wiki/Discrete_Fourier_transform#Generalized_DFT_%28shifted_and_non-linear_phase%29">generic 1D DFT</a>.
Similarly, <code>out</code> is the output array (size <code>n</code>) from <code>REDFT11</code>
and <code>out_logical</code> is the output array (size <em>N</em>) from a generic 1D DFT.</p>
<p>Here is how the symmetric input is generated:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#75715e">// the first half of the array is identical
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>    in_logical[i] <span style="color:#f92672">=</span> in[i];
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// second half is filled according to odd symmetry around n-0.5
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>    in_logical[n <span style="color:#f92672">+</span> i] <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>in[n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">-</span> i];
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The checks are a little bit more involved.
The logically equivalent DFT output should be purely real-valued:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> N; <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (fabs(cimag(out_logical[i])) <span style="color:#f92672">&gt;</span> eps) {
</span></span><span style="display:flex;"><span>        printf(<span style="color:#e6db74">&#34;error: imag of [%d] is %g</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, i, cimag(out_logical[i]));
</span></span><span style="display:flex;"><span>        status <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        printf(<span style="color:#e6db74">&#34;imag of [%d] is %g</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, i, cimag(out_logical[i]));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The first <code>n</code> values should be identical between <code>REDFT11</code> and the generalized DFT:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>    delta <span style="color:#f92672">=</span> creal(out_logical[i]) <span style="color:#f92672">-</span> out[i];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (fabs(delta) <span style="color:#f92672">&gt;</span> eps) {
</span></span><span style="display:flex;"><span>        printf(<span style="color:#e6db74">&#34;error: delta of [%d] is %g</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, i, delta);
</span></span><span style="display:flex;"><span>        status <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        printf(<span style="color:#e6db74">&#34;match of [%d] (delta=%g)</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, i, delta);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The remaining values should have odd symmetry around <code>n-0.5</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>    delta <span style="color:#f92672">=</span> creal(out_logical[n <span style="color:#f92672">+</span> i]) <span style="color:#f92672">-</span> (<span style="color:#f92672">-</span>out[n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">-</span> i]);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (fabs(delta) <span style="color:#f92672">&gt;</span> eps) {
</span></span><span style="display:flex;"><span>        printf(<span style="color:#e6db74">&#34;error: delta of [%d] is %g</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, n <span style="color:#f92672">+</span> i, delta);
</span></span><span style="display:flex;"><span>        status <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        printf(<span style="color:#e6db74">&#34;match of [%d] (delta=%g)</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, n <span style="color:#f92672">+</span> i, delta);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The full example can be found in <a href="src/test_1d_redft11.c"><code>src/test_1d_redft11.c</code></a>.</p>
<h4 id="rodft00-dst-i">
  RODFT00 (DST-I)
  <a class="anchor" href="#rodft00-dst-i">#</a>
</h4>
<p>In case of the real-valued odd-parity DFT with no shifts in either input or output array (RODFT00),
also called the DST-I, the corresponding logical DFT size is given by <em>N</em> = 2(<code>n</code>+1), corresponding to <code>n</code> = <em>N</em>/2-1.
Note that the periodicity of <em>N</em> of the logical input array in combination with odd symmetry <em>X_j = -X_{n-j}</em>
leads to <em>X_0 = -X_0</em> which is equivalent to <em>X_0 = 0</em>.
This first always-zero element of the input array is not explicitly included in the input to FFTW
and the input array thus has a size of one less and the indices of the symmetry axis shift by 1.</p>
<p>The formal definition of the RODFT00 is given below:</p>
<p><!-- raw HTML omitted -->$$</p>
<p>$$<!-- raw HTML omitted -->
<img src="eqn/rodft00.png" alt="RODFT00 formula" /></p>
<p>The inverse of this transform is RODFT00 itself.
The input array is assumed to have odd symmetry around <em>j=-1</em> and odd symmetry also around <em>j=n</em>.</p>
<p><img src="img/rodft00.png" alt="RODFT00" /></p>
<p>In order to demonstrate the use of this method,
the logically equivalent DFT input is filled appropriately and its output is checked against <code>RODFT00</code>.
In the following code, <code>in</code> is the input array (size <code>n</code>) given to <code>RODFT00</code>
and <code>in_logical</code> is the (complex-valued) input array (size <em>N</em>) handed to a
<a href="https://en.wikipedia.org/wiki/Discrete_Fourier_transform#Generalized_DFT_%28shifted_and_non-linear_phase%29">generic 1D DFT</a>.
Similarly, <code>out</code> is the output array (size <code>n</code>) from <code>RODFT00</code>
and <code>out_logical</code> is the output array (size <em>N</em>) from a generic 1D DFT.</p>
<p>Here is how the symmetric input is generated:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#75715e">// the first half of the array is identical
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// except the first 0 (and the rest of the array being shifted)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>in_logical[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.0</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>    in_logical[i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> in[i];
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// second half is filled according to odd symmetry around (n+1)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>in_logical[n <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.0</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>    in_logical[n <span style="color:#f92672">+</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">+</span> i] <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>in[n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">-</span> i];
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The checks are a little bit more involved.
The logically equivalent DFT output should be purely imaginary-valued:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> N; <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (fabs(creal(out_logical[i])) <span style="color:#f92672">&gt;</span> eps) {
</span></span><span style="display:flex;"><span>        printf(<span style="color:#e6db74">&#34;error: real of [%d] is %g</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, i, creal(out_logical[i]));
</span></span><span style="display:flex;"><span>        status <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        printf(<span style="color:#e6db74">&#34;real of [%d] is %g</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, i, creal(out_logical[i]));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Odd symmetry about <code>0</code> implies that the imaginary part of the first output should be zero:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (fabs(cimag(out_logical[<span style="color:#ae81ff">0</span>])) <span style="color:#f92672">&gt;</span> eps) {
</span></span><span style="display:flex;"><span>    printf(<span style="color:#e6db74">&#34;error: delta of [%d] is %g</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, <span style="color:#ae81ff">0</span>, <span style="color:#f92672">-</span>cimag(out_logical[<span style="color:#ae81ff">0</span>]));
</span></span><span style="display:flex;"><span>    status <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>    printf(<span style="color:#e6db74">&#34;match of [%d] (delta=%g)</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, <span style="color:#ae81ff">0</span>, <span style="color:#f92672">-</span>cimag(out_logical[<span style="color:#ae81ff">0</span>]));
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The next <code>n</code> values should have the output of <code>RODFT00</code> in their negative imaginary parts
with one index offset to account for the first zero in the input:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>    delta <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>cimag(out_logical[i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>]) <span style="color:#f92672">-</span> out[i];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (fabs(delta) <span style="color:#f92672">&gt;</span> eps) {
</span></span><span style="display:flex;"><span>        printf(<span style="color:#e6db74">&#34;error: delta of [%d] is %g</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, delta);
</span></span><span style="display:flex;"><span>        status <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        printf(<span style="color:#e6db74">&#34;match of [%d] (delta=%g)</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, delta);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Odd symmetry about <code>n</code> in the input to <code>RODFT00</code> implies
odd symmetry in the output of the logically-equivalent DFT about <code>n+1</code> due to the index shift by one:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (fabs(cimag(out_logical[n <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>])) <span style="color:#f92672">&gt;</span> eps) {
</span></span><span style="display:flex;"><span>    printf(<span style="color:#e6db74">&#34;error: delta of [%d] is %g</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, n <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>,
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">-</span>cimag(out_logical[n <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>]));
</span></span><span style="display:flex;"><span>    status <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>    printf(<span style="color:#e6db74">&#34;match of [%d] (delta=%g)</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, n <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, <span style="color:#f92672">-</span>cimag(out_logical[n <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>]));
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The remaining values should have odd symmetry around <code>n+1</code>
(note again that the real output from <code>RODFT00</code> needs to be compared against
the negative imaginary parts in the output of the logically equivalent DFT shifted by one full index):</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>    delta <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>cimag(out_logical[n <span style="color:#f92672">+</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">+</span> i]) <span style="color:#f92672">-</span> (<span style="color:#f92672">-</span>out[n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">-</span> i]);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (fabs(delta) <span style="color:#f92672">&gt;</span> eps) {
</span></span><span style="display:flex;"><span>        printf(<span style="color:#e6db74">&#34;error: delta of [%d] is %g</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, n <span style="color:#f92672">+</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">+</span> i, delta);
</span></span><span style="display:flex;"><span>        status <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        printf(<span style="color:#e6db74">&#34;match of [%d] (delta=%g)</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, n <span style="color:#f92672">+</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">+</span> i, delta);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The full example can be found in <a href="src/test_1d_rodft00.c"><code>src/test_1d_rodft00.c</code></a>.</p>
<h4 id="rodft10-dst-ii">
  RODFT10 (DST-II)
  <a class="anchor" href="#rodft10-dst-ii">#</a>
</h4>
<p>In case of the real-valued odd-parity DFT with shifted input data (RODFT10),
also called the DST-II, the corresponding logical DFT size is given by <em>N</em> = 2<code>n</code>, corresponding to <code>n</code> = <em>N</em>/2.
This function is commonly known as &ldquo;the&rdquo; DST.</p>
<p>The formal definition of the RODFT10 is given below:</p>
<p><!-- raw HTML omitted -->$$</p>
<p>$$<!-- raw HTML omitted -->
<img src="eqn/rodft10.png" alt="RODFT10 formula" /></p>
<p>The inverse of this transform is RODFT01.
The input array is assumed to have odd symmetry around <em>j=-0.5</em> and odd symmetry also around <em>j=n-0.5</em>.</p>
<p><img src="img/rodft10.png" alt="RODFT10" /></p>
<p>In order to demonstrate the use of this method,
the logically equivalent DFT input is filled appropriately and its output is checked against <code>RODFT10</code>.
In the following code, <code>in</code> is the input array (size <code>n</code>) given to <code>RODFT10</code>
and <code>in_logical</code> is the (complex-valued) input array (size <em>N</em>) handed to a
<a href="https://en.wikipedia.org/wiki/Discrete_Fourier_transform#Generalized_DFT_%28shifted_and_non-linear_phase%29">generic 1D DFT</a>.
Similarly, <code>out</code> is the output array (size <code>n</code>) from <code>RODFT10</code>
and <code>out_logical</code> is the output array (size <em>N</em>) from a generic 1D DFT.</p>
<p>Here is how the symmetric input is generated:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#75715e">// the first half of the array is identical
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>    in_logical[i] <span style="color:#f92672">=</span> in[i];
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// second half is filled according to odd symmetry around (n-0.5)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>    in_logical[n <span style="color:#f92672">+</span> i] <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>in[n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">-</span> i];
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The checks are a little bit more involved.
The logically equivalent DFT output should be purely imaginary-valued:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> N; <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (fabs(creal(out_logical[i])) <span style="color:#f92672">&gt;</span> eps) {
</span></span><span style="display:flex;"><span>        printf(<span style="color:#e6db74">&#34;error: real of [%d] is %g</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, i, creal(out_logical[i]));
</span></span><span style="display:flex;"><span>        status <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        printf(<span style="color:#e6db74">&#34;real of [%d] is %g</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, i, creal(out_logical[i]));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The output of <code>RODFT10</code> is shifted by one index to the left with respect to the logically-equivalent DFT,
since the first input is constrained to be zero (resulting in odd parity about <code>-1</code> in the input to <code>RODFT10</code>).
Odd symmetry about <code>0</code> implies that the imaginary part of the first output should be zero:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (fabs(cimag(out_logical[<span style="color:#ae81ff">0</span>])) <span style="color:#f92672">&gt;</span> eps) {
</span></span><span style="display:flex;"><span>    printf(<span style="color:#e6db74">&#34;error: delta of [%d] is %g</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, <span style="color:#ae81ff">0</span>, <span style="color:#f92672">-</span>cimag(out_logical[<span style="color:#ae81ff">0</span>]));
</span></span><span style="display:flex;"><span>    status <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>    printf(<span style="color:#e6db74">&#34;match of [%d] (delta=%g)</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, <span style="color:#ae81ff">0</span>, <span style="color:#f92672">-</span>cimag(out_logical[<span style="color:#ae81ff">0</span>]));
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The next <code>n</code> values should have the output of <code>RODFT10</code> in their negative imaginary parts
with one index offset to account for the first zero in the input:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>    delta <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>cimag(out_logical[i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>]) <span style="color:#f92672">-</span> out[i];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (fabs(delta) <span style="color:#f92672">&gt;</span> eps) {
</span></span><span style="display:flex;"><span>        printf(<span style="color:#e6db74">&#34;error: delta of [%d] is %g</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, delta);
</span></span><span style="display:flex;"><span>        status <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        printf(<span style="color:#e6db74">&#34;match of [%d] (delta=%g)</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, delta);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The remaining values have even symmetry around <code>n-1</code>
(note again that the real output from <code>RODFT10</code> needs to be compared against
the negative imaginary parts in the output of the logically equivalent DFT shifted by one full index):</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>; <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>    delta <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>cimag(out_logical[n <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">+</span> i]) <span style="color:#f92672">-</span> out[n <span style="color:#f92672">-</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">-</span> i];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (fabs(delta) <span style="color:#f92672">&gt;</span> eps) {
</span></span><span style="display:flex;"><span>        printf(<span style="color:#e6db74">&#34;error: delta of [%d] is %g</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, n <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">+</span> i, delta);
</span></span><span style="display:flex;"><span>        status <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        printf(<span style="color:#e6db74">&#34;match of [%d] (delta=%g)</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, n <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">+</span> i, delta);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The full example can be found in <a href="src/test_1d_rodft10.c"><code>src/test_1d_rodft10.c</code></a>.</p>
<h4 id="rodft01-dst-iii">
  RODFT01 (DST-III)
  <a class="anchor" href="#rodft01-dst-iii">#</a>
</h4>
<p>In case of the real-valued odd-parity DFT with shifted output data (RODFT01),
also called the DST-III, the corresponding logical DFT size is given by <em>N</em> = 2<code>n</code>, corresponding to <code>n</code> = <em>N</em>/2.
This function is commonly known as &ldquo;the&rdquo; inverse DST (IDST).</p>
<p>The formal definition of the RODFT01 is given below:</p>
<p><!-- raw HTML omitted -->$$</p>
<p>$$<!-- raw HTML omitted -->
<img src="eqn/rodft01.png" alt="RODFT01 formula" /></p>
<p>The inverse of this transform is RODFT10.
The input array is assumed to have odd symmetry around <em>j=-1</em> and even symmetry around <em>j=n-1</em>.</p>
<p><img src="img/rodft01.png" alt="RODFT01" /></p>
<p>In order to demonstrate the use of this method,
the logically equivalent DFT input is filled appropriately and its output is checked against <code>RODFT01</code>.
In the following code, <code>in</code> is the input array (size <code>n</code>) given to <code>RODFT01</code>
and <code>in_logical</code> is the (complex-valued) input array (size <em>N</em>) handed to a
<a href="https://en.wikipedia.org/wiki/Discrete_Fourier_transform#Generalized_DFT_%28shifted_and_non-linear_phase%29">generic 1D DFT</a>.
Similarly, <code>out</code> is the output array (size <code>n</code>) from <code>RODFT01</code>
and <code>out_logical</code> is the output array (size <em>N</em>) from a generic 1D DFT.</p>
<p>The input of <code>RODFT01</code> is shifted by one index to the left with respect to the logically-equivalent DFT,
since the first input is constrained to be zero (resulting in odd parity about <code>-1</code> in the input to <code>RODFT01</code>).
Here is how the symmetric input is generated:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#75715e">// a zero in the first entry is needed to satisfy
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// odd symmetry about -1 in the shifted input array
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>in_logical[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// the first half of the array is identical up to shift
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>    in_logical[i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> in[i];
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// second half is filled according to even symmetry around (n-1)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>; <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>    in_logical[n <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">+</span> i] <span style="color:#f92672">=</span> in[n <span style="color:#f92672">-</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">-</span> i];
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The checks are a little bit more involved.
The logically equivalent DFT output should be purely imaginary-valued:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> N; <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (fabs(creal(out_logical[i])) <span style="color:#f92672">&gt;</span> eps) {
</span></span><span style="display:flex;"><span>        printf(<span style="color:#e6db74">&#34;error: real of [%d] is %g</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, i, creal(out_logical[i]));
</span></span><span style="display:flex;"><span>        status <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        printf(<span style="color:#e6db74">&#34;real of [%d] is %g</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, i, creal(out_logical[i]));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The first <code>n</code> values should have the output of <code>RODFT01</code> in their negative imaginary parts:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>    delta <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>cimag(out_logical[i]) <span style="color:#f92672">-</span> out[i];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (fabs(delta) <span style="color:#f92672">&gt;</span> eps) {
</span></span><span style="display:flex;"><span>        printf(<span style="color:#e6db74">&#34;error: delta of [%d] is %g</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, i, delta);
</span></span><span style="display:flex;"><span>        status <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        printf(<span style="color:#e6db74">&#34;match of [%d] (delta=%g)</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, i, delta);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The remaining values have odd symmetry around <code>n-0.5</code>
(note again that the real output from <code>RODFT01</code> needs to be compared against
the negative imaginary parts in the output of the logically equivalent DFT shifted by one full index):</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>    delta <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>cimag(out_logical[n <span style="color:#f92672">+</span> i]) <span style="color:#f92672">-</span> (<span style="color:#f92672">-</span>out[n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">-</span> i]);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (fabs(delta) <span style="color:#f92672">&gt;</span> eps) {
</span></span><span style="display:flex;"><span>        printf(<span style="color:#e6db74">&#34;error: delta of [%d] is %g</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, n <span style="color:#f92672">+</span> i, delta);
</span></span><span style="display:flex;"><span>        status <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        printf(<span style="color:#e6db74">&#34;match of [%d] (delta=%g)</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, n <span style="color:#f92672">+</span> i, delta);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The full example can be found in <a href="src/test_1d_rodft01.c"><code>src/test_1d_rodft01.c</code></a>.</p>
<h4 id="rodft11-dst-iv">
  RODFT11 (DST-IV)
  <a class="anchor" href="#rodft11-dst-iv">#</a>
</h4>
<p>In case of the real-valued odd-parity DFT with both shifted input and output data (RODFT11),
also called the DST-IV, the corresponding logical DFT size is given by <em>N</em> = 2<code>n</code>, corresponding to <code>n</code> = <em>N</em>/2.</p>
<p>The formal definition of the RODFT11 is given below:</p>
<p><!-- raw HTML omitted -->$$</p>
<p>$$<!-- raw HTML omitted -->
<img src="eqn/rodft11.png" alt="RODFT11 formula" /></p>
<p>The inverse of this transform is RODFT11 itself.
The input array is assumed to have odd symmetry around <em>j=-0.5</em> and even symmetry around <em>j=n-0.5</em>.</p>
<p><img src="img/rodft11.png" alt="RODFT11" /></p>
<p>In order to demonstrate the use of this method,
the logically equivalent DFT input is filled appropriately and its output is checked against <code>RODFT11</code>.
In the following code, <code>in</code> is the input array (size <code>n</code>) given to <code>RODFT11</code>
and <code>in_logical</code> is the (complex-valued) input array (size <em>N</em>) handed to a
<a href="https://en.wikipedia.org/wiki/Discrete_Fourier_transform#Generalized_DFT_%28shifted_and_non-linear_phase%29">generic 1D DFT</a>.
Similarly, <code>out</code> is the output array (size <code>n</code>) from <code>RODFT11</code>
and <code>out_logical</code> is the output array (size <em>N</em>) from a generic 1D DFT.</p>
<p>Here is how the symmetric input is generated:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#75715e">// the first half of the array is identical up to shift
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>    in_logical[i] <span style="color:#f92672">=</span> in[i];
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// second half is filled according to even symmetry around (n-0.5)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>    in_logical[n <span style="color:#f92672">+</span> i] <span style="color:#f92672">=</span> in[n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">-</span> i];
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The checks are a little bit more involved.
The logically equivalent DFT output should be purely imaginary-valued:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> N; <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (fabs(creal(out_logical[i])) <span style="color:#f92672">&gt;</span> eps) {
</span></span><span style="display:flex;"><span>        printf(<span style="color:#e6db74">&#34;error: real of [%d] is %g</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, i, creal(out_logical[i]));
</span></span><span style="display:flex;"><span>        status <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        printf(<span style="color:#e6db74">&#34;real of [%d] is %g</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, i, creal(out_logical[i]));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The first <code>n</code> values should have the output of <code>RODFT11</code> in their negative imaginary parts:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>    delta <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>cimag(out_logical[i]) <span style="color:#f92672">-</span> out[i];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (fabs(delta) <span style="color:#f92672">&gt;</span> eps) {
</span></span><span style="display:flex;"><span>        printf(<span style="color:#e6db74">&#34;error: delta of [%d] is %g</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, i, delta);
</span></span><span style="display:flex;"><span>        status <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        printf(<span style="color:#e6db74">&#34;match of [%d] (delta=%g)</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, i, delta);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The remaining values have even symmetry around <code>n-0.5</code>
(note again that the real output from <code>RODFT11</code> needs to be compared against
the negative imaginary parts in the output of the logically equivalent DFT):</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>    delta <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>cimag(out_logical[n <span style="color:#f92672">+</span> i]) <span style="color:#f92672">-</span> out[n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">-</span> i];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (fabs(delta) <span style="color:#f92672">&gt;</span> eps) {
</span></span><span style="display:flex;"><span>        printf(<span style="color:#e6db74">&#34;error: delta of [%d] is %g</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, n <span style="color:#f92672">+</span> i, delta);
</span></span><span style="display:flex;"><span>        status <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        printf(<span style="color:#e6db74">&#34;match of [%d] (delta=%g)</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, n <span style="color:#f92672">+</span> i, delta);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The full example can be found in <a href="src/test_1d_rodft11.c"><code>src/test_1d_rodft11.c</code></a>.</p>
<h2 id="two-dimensional-examples">
  Two-Dimensional Examples
  <a class="anchor" href="#two-dimensional-examples">#</a>
</h2>
<p>The next section deals with the computation of two-dimensional (2D) DFTs of random input data.</p>
<h3 id="2d-complex-to-complex">
  2D complex-to-complex
  <a class="anchor" href="#2d-complex-to-complex">#</a>
</h3>
<p>A first example for the computation of two-dimensional Fourier transforms using FFTW is given here:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;math.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;complex.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;fftw3.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;util.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">test_2d_c2c</span>(<span style="color:#66d9ef">int</span> n0, <span style="color:#66d9ef">int</span> n1) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> dir <span style="color:#f92672">=</span> FFTW_FORWARD;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    fftw_complex <span style="color:#f92672">*</span>in <span style="color:#f92672">=</span> fftw_alloc_complex(n0 <span style="color:#f92672">*</span> n1);
</span></span><span style="display:flex;"><span>    fftw_complex <span style="color:#f92672">*</span>out <span style="color:#f92672">=</span> fftw_alloc_complex(n0 <span style="color:#f92672">*</span> n1);
</span></span><span style="display:flex;"><span>    fftw_complex <span style="color:#f92672">*</span>ref_out <span style="color:#f92672">=</span> fftw_alloc_complex(n0 <span style="color:#f92672">*</span> n1);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    fftw_plan p <span style="color:#f92672">=</span> fftw_plan_dft_2d(n0, n1, in, out, dir, FFTW_ESTIMATE);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// random input
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    fill_random_2d_cplx(n0, n1, in);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// manually compute DFT for reference
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> idx_k, idx_j;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">double</span> phi;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> k0 <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; k0 <span style="color:#f92672">&lt;</span> n0; <span style="color:#f92672">++</span>k0) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> k1 <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; k1 <span style="color:#f92672">&lt;</span> n1; <span style="color:#f92672">++</span>k1) {
</span></span><span style="display:flex;"><span>            idx_k <span style="color:#f92672">=</span> k0 <span style="color:#f92672">*</span> n1 <span style="color:#f92672">+</span> k1;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            ref_out[idx_k] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j0 <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j0 <span style="color:#f92672">&lt;</span> n0; <span style="color:#f92672">++</span>j0) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j1 <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j1 <span style="color:#f92672">&lt;</span> n1; <span style="color:#f92672">++</span>j1) {
</span></span><span style="display:flex;"><span>                    idx_j <span style="color:#f92672">=</span> j0 <span style="color:#f92672">*</span> n1 <span style="color:#f92672">+</span> j1;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                    phi <span style="color:#f92672">=</span> dir <span style="color:#f92672">*</span> <span style="color:#ae81ff">2.0</span> <span style="color:#f92672">*</span> M_PI <span style="color:#f92672">*</span> (
</span></span><span style="display:flex;"><span>                              k0 <span style="color:#f92672">*</span> j0 <span style="color:#f92672">/</span> ((<span style="color:#66d9ef">double</span>) n0)
</span></span><span style="display:flex;"><span>                            <span style="color:#f92672">+</span> k1 <span style="color:#f92672">*</span> j1 <span style="color:#f92672">/</span> ((<span style="color:#66d9ef">double</span>) n1) );
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                    ref_out[idx_k] <span style="color:#f92672">+=</span> in[idx_j] <span style="color:#f92672">*</span> cexp(I <span style="color:#f92672">*</span> phi);
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    fftw_execute(p);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// compare outputs
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">double</span> eps <span style="color:#f92672">=</span> <span style="color:#ae81ff">1.0e-12</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> status <span style="color:#f92672">=</span> compare_2d_cplx(n0, n1, ref_out, out, eps);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> status;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span> <span style="color:#f92672">**</span>argv) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> status <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    status <span style="color:#f92672">+=</span> test_2d_c2c(<span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">4</span>);
</span></span><span style="display:flex;"><span>    status <span style="color:#f92672">+=</span> test_2d_c2c(<span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>);
</span></span><span style="display:flex;"><span>    status <span style="color:#f92672">+=</span> test_2d_c2c(<span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">4</span>);
</span></span><span style="display:flex;"><span>    status <span style="color:#f92672">+=</span> test_2d_c2c(<span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">5</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> status;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>As usual, arrays are allocated to the specified size and filled with random data.
The two-dimensional complex-valued DFT is computed manually for reference
and the outputs are compared against the result of FFTW.
The product of the one-dimensional DFTs along the two dimensions is computed here
via addition of the corresponding phases in the exponent of the complex-valued basis function.</p>
<p>The code can be found in <a href="src/test_2d_c2c.c"><code>src/test_2d_c2c.c</code></a>.</p>
<h3 id="2d-complex-to-real">
  2D complex-to-real
  <a class="anchor" href="#2d-complex-to-real">#</a>
</h3>
<p>The two-dimensional <code>c2r</code> transform can make use of the Hermitian symmetry
(<a href="https://github.com/jonathanschilling/fftw_tutorial#1d-complex-to-real-and-real-to-complex">see above</a>)
to reduce the computational work in the <em>last</em> dimension of the input data by about a factor of 2.
The input data thus has to have a shape of (<code>n0</code>x<code>n1_cplx</code>) where <code>n1_cplx = n1/2+1</code> (division by 2 rounded down)
and (<code>n0</code>x<code>n1</code>) is the logical size of the DFT and also the size of the real-valued output arrays.</p>
<p>The arrays are allocated as follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span>fftw_complex <span style="color:#f92672">*</span>in <span style="color:#f92672">=</span> fftw_alloc_complex(n0 <span style="color:#f92672">*</span> n1_cplx);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">double</span> <span style="color:#f92672">*</span>out <span style="color:#f92672">=</span> fftw_alloc_real(n0 <span style="color:#f92672">*</span> n1);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">double</span> <span style="color:#f92672">*</span>ref_out <span style="color:#f92672">=</span> fftw_alloc_real(n0 <span style="color:#f92672">*</span> n1);
</span></span></code></pre></div><p>The manual transform that is computed for reference is done as follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> idx_k, idx_j;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">double</span> phi, real;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> k0 <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; k0 <span style="color:#f92672">&lt;</span> n0; <span style="color:#f92672">++</span>k0) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> k1 <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; k1 <span style="color:#f92672">&lt;</span> n1; <span style="color:#f92672">++</span>k1) {
</span></span><span style="display:flex;"><span>        idx_k <span style="color:#f92672">=</span> k0 <span style="color:#f92672">*</span> n1 <span style="color:#f92672">+</span> k1;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        ref_out[idx_k] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j0 <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j0 <span style="color:#f92672">&lt;</span> n0; <span style="color:#f92672">++</span>j0) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j1 <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j1 <span style="color:#f92672">&lt;</span> n1_cplx; <span style="color:#f92672">++</span>j1) {
</span></span><span style="display:flex;"><span>                idx_j <span style="color:#f92672">=</span> j0 <span style="color:#f92672">*</span> n1_cplx <span style="color:#f92672">+</span> j1;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                phi <span style="color:#f92672">=</span> <span style="color:#ae81ff">2.0</span> <span style="color:#f92672">*</span> M_PI <span style="color:#f92672">*</span> (  k0 <span style="color:#f92672">*</span> j0 <span style="color:#f92672">/</span> ((<span style="color:#66d9ef">double</span>) n0)
</span></span><span style="display:flex;"><span>                                    <span style="color:#f92672">+</span> k1 <span style="color:#f92672">*</span> j1 <span style="color:#f92672">/</span> ((<span style="color:#66d9ef">double</span>) n1) );
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// output is purely real,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#75715e">// so compute only real part
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                real <span style="color:#f92672">=</span> creal(in[idx_j]) <span style="color:#f92672">*</span> cos(phi) <span style="color:#f92672">-</span> cimag(in[idx_j]) <span style="color:#f92672">*</span> sin(phi);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                ref_out[idx_k] <span style="color:#f92672">+=</span> real;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// add symmetric entries twice
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#75715e">// n1/2+n1%2 is n1/2 if n1 is even
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#75715e">// and it is n1/2+1 if n1 is odd
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#66d9ef">if</span> (j1 <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> j1 <span style="color:#f92672">&lt;</span> n1 <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">+</span> n1 <span style="color:#f92672">%</span> <span style="color:#ae81ff">2</span>) {
</span></span><span style="display:flex;"><span>                    ref_out[idx_k] <span style="color:#f92672">+=</span> real;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The full example can be found in <a href="src/test_2d_c2r.c"><code>src/test_2d_c2r.c</code></a>.</p>
<h3 id="2d-real-to-complex">
  2D real-to-complex
  <a class="anchor" href="#2d-real-to-complex">#</a>
</h3>
<p>The two-dimensional <code>r2c</code> transform can make use of the Hermitian symmetry
(<a href="https://github.com/jonathanschilling/fftw_tutorial#1d-complex-to-real-and-real-to-complex">see above</a>)
to reduce the computational work in the <em>last</em> dimension of the output data by about a factor of 2.
The real-valued input data has to have a shape of (<code>n0</code>x<code>n1</code>), which is also the logical size of the DFT.
The output data then has a shape of (<code>n0</code>x<code>n1_cplx</code>) where <code>n1_cplx = n1/2+1</code> (division by 2 rounded down).</p>
<p>The arrays are allocated as follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">double</span> <span style="color:#f92672">*</span>in <span style="color:#f92672">=</span> fftw_alloc_real(n0 <span style="color:#f92672">*</span> n1);
</span></span><span style="display:flex;"><span>fftw_complex <span style="color:#f92672">*</span>out <span style="color:#f92672">=</span> fftw_alloc_complex(n0 <span style="color:#f92672">*</span> n1_cplx);
</span></span><span style="display:flex;"><span>fftw_complex <span style="color:#f92672">*</span>ref_out <span style="color:#f92672">=</span> fftw_alloc_complex(n0 <span style="color:#f92672">*</span> n1_cplx);
</span></span></code></pre></div><p>The manual transform that is computed for reference is done as follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> idx_k, idx_j;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">double</span> phi;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> k0 <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; k0 <span style="color:#f92672">&lt;</span> n0; <span style="color:#f92672">++</span>k0) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> k1 <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; k1 <span style="color:#f92672">&lt;</span> n1_cplx; <span style="color:#f92672">++</span>k1) {
</span></span><span style="display:flex;"><span>        idx_k <span style="color:#f92672">=</span> k0 <span style="color:#f92672">*</span> n1_cplx <span style="color:#f92672">+</span> k1;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        ref_out[idx_k] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j0 <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j0 <span style="color:#f92672">&lt;</span> n0; <span style="color:#f92672">++</span>j0) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j1 <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j1 <span style="color:#f92672">&lt;</span> n1; <span style="color:#f92672">++</span>j1) {
</span></span><span style="display:flex;"><span>                idx_j <span style="color:#f92672">=</span> j0 <span style="color:#f92672">*</span> n1 <span style="color:#f92672">+</span> j1;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                phi <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">2.0</span> <span style="color:#f92672">*</span> M_PI <span style="color:#f92672">*</span> (  k0 <span style="color:#f92672">*</span> j0 <span style="color:#f92672">/</span> ((<span style="color:#66d9ef">double</span>) n0)
</span></span><span style="display:flex;"><span>                                     <span style="color:#f92672">+</span> k1 <span style="color:#f92672">*</span> j1 <span style="color:#f92672">/</span> ((<span style="color:#66d9ef">double</span>) n1) );
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                ref_out[idx_k] <span style="color:#f92672">+=</span> in[idx_j] <span style="color:#f92672">*</span> cexp(I<span style="color:#f92672">*</span>phi);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The full example can be found in <a href="src/test_2d_r2c.c"><code>src/test_2d_r2c.c</code></a>.</p>
<h3 id="2d-real-to-real">
  2D real-to-real
  <a class="anchor" href="#2d-real-to-real">#</a>
</h3>
<p>Two-dimensional real-to-real DFTs can be defined with any of the one-dimensional transforms
in each of the two dimensions. This implies that for eight one-dimensional transforms
there is a total of 64 possible combinations that exceed the scope of this tutorial
and also do not contribute much insight.</p>
<p>Note that FFTW computes the <em>separable product</em> of the transforms along each dimension
and not the true multi-dimensional DFT.
This can be understood intuitively by the addition formulas for sine and cosine:</p>
<p><!-- raw HTML omitted -->$$</p>
<p>$$<!-- raw HTML omitted -->
<img src="eqn/sin_cos_add.png" alt="Addition formulas for sine and cosine" /></p>
<p>FFTW&rsquo;s two-dimensional real-to-real DFTs can be used to compute the products on the right-hand side
of above equation and two such DFts have to be added together to arrive at the true
two-dimensional DFT with the Fourier kernel as on the left-hand side of above equation.</p>
<p>In the following, two examples are presented.
First, a mixed <code>r2r</code> DFT with <code>REDFT10</code> in the first dimension and <code>RODFT10</code> in the second dimension is computed.
Second, a true two-dimensional DFT in computed using two FFTW calls.</p>
<h4 id="2d-redft10rodft10">
  2D REDFT10+RODFT10
  <a class="anchor" href="#2d-redft10rodft10">#</a>
</h4>
<p>An example of a two-dimensional transform is presented
with <code>REDFT10</code> in the first dimension and <code>RODFT10</code> in the second dimension.</p>
<p>The basis functions for the two dimensions are computed separately:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#75715e">// REDFT10 in first dimension
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>basis_0 <span style="color:#f92672">=</span> <span style="color:#ae81ff">2.0</span> <span style="color:#f92672">*</span> cos(M_PI <span style="color:#f92672">*</span> (j0 <span style="color:#f92672">+</span> <span style="color:#ae81ff">0.5</span>) <span style="color:#f92672">*</span> k0 <span style="color:#f92672">/</span> ((<span style="color:#66d9ef">double</span>) n0));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// RODFT10 in second dimension
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>basis_1 <span style="color:#f92672">=</span> <span style="color:#ae81ff">2.0</span> <span style="color:#f92672">*</span> sin(M_PI <span style="color:#f92672">*</span> (j1 <span style="color:#f92672">+</span> <span style="color:#ae81ff">0.5</span>) <span style="color:#f92672">*</span> (k1 <span style="color:#f92672">+</span> <span style="color:#ae81ff">1.0</span>) <span style="color:#f92672">/</span> ((<span style="color:#66d9ef">double</span>) n1));
</span></span></code></pre></div><p>The contribution to the output array is computed as follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span>ref_out[idx_k] <span style="color:#f92672">+=</span> in[idx_j] <span style="color:#f92672">*</span> basis_0 <span style="color:#f92672">*</span> basis_1;
</span></span></code></pre></div><p>The full example can be found in <a href="src/test_2d_r2r_e10_o10.c"><code>src/test_2d_r2r_e10_o10.c</code></a>.</p>
<h4 id="true-2d-idct-using-fftw">
  True 2D IDCT using FFTW
  <a class="anchor" href="#true-2d-idct-using-fftw">#</a>
</h4>
<p>A true two-dimensional inverse discrete cosine transform is computed using FFTW in this example:</p>
<p><!-- raw HTML omitted -->$$</p>
<p>$$<!-- raw HTML omitted -->
<img src="eqn/true_2d_idct.png" alt="True two-dimensional IDCT" /></p>
<p>FFTW can only compute the separable product of one-dimensional transforms for multi-dimensional transform.
Above kernel function thus has to be split up by application of the addition formula for sine and cosine:</p>
<p><!-- raw HTML omitted -->$$</p>
<p>$$<!-- raw HTML omitted -->
<img src="eqn/true_2d_idct_kernel.png" alt="True two-dimensional IDCT kernel" /></p>
<p>The left half of above equation is computed using a two-dimensional <code>REDFT01</code>
and the right half is computed using a two-dimensional <code>RODFT01</code>.
The outputs of these transforms are subtracted from each other to yield the desired result.</p>
<p>First consider the naive implementation in plain <code>C</code>.</p>
<p>The input and output arrays are allocated and filled with random data:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">double</span> <span style="color:#f92672">*</span>in <span style="color:#f92672">=</span> fftw_alloc_real(n0 <span style="color:#f92672">*</span> n1);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">double</span> <span style="color:#f92672">*</span>ref_out <span style="color:#f92672">=</span> fftw_alloc_real(n0 <span style="color:#f92672">*</span> n1);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>fill_random_2d_real(n0, n1, in);
</span></span></code></pre></div><p>The two-dimensional IDCT is computed from the input data:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">double</span> basis;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> k0 <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; k0 <span style="color:#f92672">&lt;</span> n0; <span style="color:#f92672">++</span>k0) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> k1 <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; k1 <span style="color:#f92672">&lt;</span> n1; <span style="color:#f92672">++</span>k1) {
</span></span><span style="display:flex;"><span>        idx_k <span style="color:#f92672">=</span> k0 <span style="color:#f92672">*</span> n1 <span style="color:#f92672">+</span> k1;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        ref_out[idx_k] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j0 <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j0 <span style="color:#f92672">&lt;</span> n0; <span style="color:#f92672">++</span>j0) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j1 <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j1 <span style="color:#f92672">&lt;</span> n1; <span style="color:#f92672">++</span>j1) {
</span></span><span style="display:flex;"><span>                idx_j <span style="color:#f92672">=</span> j0 <span style="color:#f92672">*</span> n1 <span style="color:#f92672">+</span> j1;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                basis <span style="color:#f92672">=</span> cos(M_PI <span style="color:#f92672">*</span> (  (k0 <span style="color:#f92672">+</span> <span style="color:#ae81ff">0.5</span>) <span style="color:#f92672">*</span> j0 <span style="color:#f92672">/</span> ((<span style="color:#66d9ef">double</span>) n0)
</span></span><span style="display:flex;"><span>                                    <span style="color:#f92672">+</span> (k1 <span style="color:#f92672">+</span> <span style="color:#ae81ff">0.5</span>) <span style="color:#f92672">*</span> j1 <span style="color:#f92672">/</span> ((<span style="color:#66d9ef">double</span>) n1) ) );
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                ref_out[idx_k] <span style="color:#f92672">+=</span> in[idx_j] <span style="color:#f92672">*</span> basis;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Next, the same transform is implemented using FFTW.</p>
<p>Separate input and output array are allocated in this educational example:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">double</span> <span style="color:#f92672">*</span>in1 <span style="color:#f92672">=</span> fftw_alloc_real(n0 <span style="color:#f92672">*</span> n1);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">double</span> <span style="color:#f92672">*</span>in2 <span style="color:#f92672">=</span> fftw_alloc_real(n0 <span style="color:#f92672">*</span> n1);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">double</span> <span style="color:#f92672">*</span>out1 <span style="color:#f92672">=</span> fftw_alloc_real(n0 <span style="color:#f92672">*</span> n1);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">double</span> <span style="color:#f92672">*</span>out2 <span style="color:#f92672">=</span> fftw_alloc_real(n0 <span style="color:#f92672">*</span> n1);
</span></span></code></pre></div><p>The two two-dimensional transforms are planned:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span>fftw_plan p1 <span style="color:#f92672">=</span> fftw_plan_r2r_2d(n0, n1, in1, out1, FFTW_REDFT01, FFTW_REDFT01, FFTW_ESTIMATE);
</span></span><span style="display:flex;"><span>fftw_plan p2 <span style="color:#f92672">=</span> fftw_plan_r2r_2d(n0, n1, in2, out2, FFTW_RODFT01, FFTW_RODFT01, FFTW_ESTIMATE);
</span></span></code></pre></div><p>The next step is to fill the two input arrays <code>in1</code> and <code>in2</code> for FFTW
with appropriate data so that the results of FFTW are equivalent
to those of the naive implementation presented above.
This step is not entirely trivial and presented in detail next.</p>
<p>A two-dimensional loop over the input data <code>in</code> is set up
and all inputs to FFTW are initialized to be zero.
Then, the two input arrays are filled separately.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j0<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; j0<span style="color:#f92672">&lt;</span>n0; <span style="color:#f92672">++</span>j0) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j1<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; j1<span style="color:#f92672">&lt;</span>n1; <span style="color:#f92672">++</span>j1) {
</span></span><span style="display:flex;"><span>        idx_j <span style="color:#f92672">=</span> j0 <span style="color:#f92672">*</span> n1 <span style="color:#f92672">+</span> j1;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// make sure that all entries are zero
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        in1[idx_j] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.0</span>;
</span></span><span style="display:flex;"><span>        in2[idx_j] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.0</span>;
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/* fill in1 */</span>
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/* fill in2 */</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The input data for <code>REDFT01</code> has to be multiplied by <code>0.5</code>
for each dimension where the index is above <code>0</code> to cancel
the factor of <code>2</code> in the <a href="https://github.com/jonathanschilling/fftw_tutorial#redft01-dct-iii">definition of <code>REDFT01</code></a>
for direct correspondence with the desired true two-dimensional IDCT.
This is the <code>/* fill in1 */</code> step in above loop:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">double</span> factor <span style="color:#f92672">=</span> <span style="color:#ae81ff">1.0</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (j0 <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>    factor <span style="color:#f92672">*=</span> <span style="color:#ae81ff">0.5</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (j1 <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>    factor <span style="color:#f92672">*=</span> <span style="color:#ae81ff">0.5</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>in1[idx_j] <span style="color:#f92672">=</span> factor <span style="color:#f92672">*</span> in[idx_j];
</span></span></code></pre></div><p>The input data for <code>RODFT01</code> also needs to have entries
multiplied by <code>0.5</code> for each dimension in which the index is less than <code>n-1</code>
to cancel the factor of <code>2</code> in the <a href="https://github.com/jonathanschilling/fftw_tutorial#rodft01-dst-iii">definition of <code>RODFT01</code></a>
for direct correspondence with the desired true two-dimensional IDCT.
Additionally, the input data needs to be shifted left/down by one index
due to the <code>j+1</code> appearing in the definition of <code>RODFT01</code>.
This is the <code>/* fill in2 */</code> step in above loop:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (j0 <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> j1 <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> my_j0 <span style="color:#f92672">=</span> j0<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> my_j1 <span style="color:#f92672">=</span> j1<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    idx_j_2 <span style="color:#f92672">=</span> my_j0 <span style="color:#f92672">*</span> n1 <span style="color:#f92672">+</span> my_j1;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    factor <span style="color:#f92672">=</span> <span style="color:#ae81ff">1.0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (my_j0 <span style="color:#f92672">&lt;</span> n0<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>        factor <span style="color:#f92672">*=</span> <span style="color:#ae81ff">0.5</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (my_j1 <span style="color:#f92672">&lt;</span> n1<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>        factor <span style="color:#f92672">*=</span> <span style="color:#ae81ff">0.5</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    in2[idx_j_2] <span style="color:#f92672">=</span> factor <span style="color:#f92672">*</span> in[idx_j];
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>In the desired truely-2D IDCT, there is no contribution from the second term
in the split-basis approach used to implement this transform using FFTW
if either <code>j0==0</code> or <code>j1==0</code>, since the respecitve arguments to <code>sin</code> are zero in this case.
This motivates the check for <code>j0 &gt; 0 &amp;&amp; j1 &gt; 0</code> above.
The indices <code>j0</code> and <code>j1</code> in the <code>REDFT01</code> input are transformed to the corresponding indices <code>my_j0</code> and <code>my_j1</code>
in the input to <code>RODFT01</code>. The corresponding linear index <code>idx_j_2</code> in <code>in2</code> is computed from <code>my_j0</code> and <code>my_j1</code>.
Factors of <code>0.5</code> are required for each dimension in which the index is less than <code>n-1</code>
to cancel the factor of <code>2</code> in the definition of <code>RODFT01</code>.</p>
<p>The FFTW plans can be executed after computing the reference output
and it remains to combine the outputs by subtracting the contribution
from the two-dimensional <code>RODFT01</code> to arrive at the final result in <code>out1</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> k0 <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; k0 <span style="color:#f92672">&lt;</span> n0; <span style="color:#f92672">++</span>k0) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> k1 <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; k1 <span style="color:#f92672">&lt;</span> n1; <span style="color:#f92672">++</span>k1) {
</span></span><span style="display:flex;"><span>        idx_k <span style="color:#f92672">=</span> k0 <span style="color:#f92672">*</span> n1 <span style="color:#f92672">+</span> k1;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// subtract because cos(u+v) = cos(u)*cos(v) - sin(u)*sin(v)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        out1[idx_k] <span style="color:#f92672">-=</span> out2[idx_k];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The full example can be found in <a href="src/test_2d_r2r_true2d.c"><code>src/test_2d_r2r_true2d.c</code></a>.</p>
<h2 id="real-world-applications">
  Real-world applications
  <a class="anchor" href="#real-world-applications">#</a>
</h2>
<p>In this section, FFTW is used to evaluate the geometry
of the magnetic axis and a flux surface of a stellarator ideal magnetohydrodynamic (MHD) plasma equilibrium
as computed by the <a href="https://doi.org/10.1016/0010-4655%2886%2990058-5">Variational Moments Equilibrium Code (VMEC)</a>.</p>
<p>Here is a plot of a few of the flux surfaces of the <a href="https://www.ipp.mpg.de/w7x">Wendelstein 7-X</a> stellarator:</p>
<p><img src="img/flux_surfaces_w7x_ref_163_1_10_50_98_cut_small.png" alt="flux surfaces and magnetic axis of W7-X" /></p>
<p>Nested flux surfaces are shown in grey, red, green and blue.
The black line indicates the magnetic axis.</p>
<p>The geometry of the magnetic axis and that of a flux surface are real-valued.
Therefore, <code>c2r</code> DFTs are sufficient to compute the backward transforms to real space.</p>
<h3 id="geometry-of-the-magnetic-axis-in-a-stellarator">
  Geometry of the Magnetic Axis in a Stellarator
  <a class="anchor" href="#geometry-of-the-magnetic-axis-in-a-stellarator">#</a>
</h3>
<p>The real-space geometry of the magnetic axis (a general closed curve) is given via a one-dimensional DFT
<a href="https://github.com/jonathanschilling/fftw_tutorial#1d-complex-to-complex">evaluated using real-valued arithmetics</a>:</p>
<p><!-- raw HTML omitted -->$$</p>
<p>$$<!-- raw HTML omitted -->
<img src="eqn/magn_axis.png" alt="full Fourier series for magnetic axis" /></p>
<p>where ζ is the toroidal angle per field period in radians.
For a five-fold symmetric stellarator like W7-X, ζ ranges from 0 to 5 * 2π around the whole machine.
Conversely, the first (unique) toroidal segment of the geometry is contained within a range of ζ from 0 to 2π.</p>
<p>In this example the geometry of the magnetic axis is evaluated at regular intervals in ζ:</p>
<p><!-- raw HTML omitted -->$$</p>
<p>$$<!-- raw HTML omitted -->
<img src="eqn/grid_zeta.png" alt="grid in zeta" /></p>
<p>where <em>l</em> ranges from <code>0</code> to <code>n_ζ-1</code>.</p>
<p>Inserting this into the Fourier series for, e.g., the <em>R</em> coordinate, leads to a DFT:</p>
<p><!-- raw HTML omitted -->$$</p>
<p>$$<!-- raw HTML omitted -->
<img src="eqn/magn_axis_dft.png" alt="magnetic axis R via DFT" /></p>
<p>Note that typically the number of Fourier coefficients included in computation
of the MHD equilibrium is (much) less than the number of grid points, i.e., <em>N</em> &lt; <code>n_ζ</code>.
The physics happens in real space and certains aspects of a computation
might require a fine spatial resolution (i.e., many grid points in real space) to accurately
resolve, e.g., gradients while the overall complexity of the solution
(gouverned by the number of included Fourier coefficients) does not need to be extremely high.
FFTW only supports (logically) equally-sized input and output arrays and thus,
if less Fourier coefficients than desired grid points are to be used,
the Fourier coefficient array needs to be filled with zeros in the remaining area.</p>
<p>The axis geometry is defined as follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#75715e">// number of Fourier coefficients
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> ntor <span style="color:#f92672">=</span> <span style="color:#ae81ff">12</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// cos-parity Fourier coefficients for magnetic axis
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">double</span> R_ax_cos[<span style="color:#ae81ff">13</span>] <span style="color:#f92672">=</span> { <span style="color:#ae81ff">5.63</span>, <span style="color:#ae81ff">0.391</span>, <span style="color:#ae81ff">0.0123</span>, <span style="color:#ae81ff">1.21e-3</span>, <span style="color:#ae81ff">4.89e-6</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">5.12e-5</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">-</span><span style="color:#ae81ff">6.57e-5</span>, <span style="color:#ae81ff">2.27e-6</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">9.28e-5</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">5.32e-7</span>, <span style="color:#ae81ff">6.67e-5</span>, <span style="color:#ae81ff">5.72e-5</span>, <span style="color:#ae81ff">2.38e-5</span> };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// sin-parity Fourier coefficients for magnetic axis
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">double</span> R_ax_sin[<span style="color:#ae81ff">13</span>] <span style="color:#f92672">=</span> { <span style="color:#ae81ff">0.0</span>, <span style="color:#ae81ff">0.0727</span>, <span style="color:#ae81ff">6.34e-3</span>, <span style="color:#ae81ff">5.84e-3</span>, <span style="color:#ae81ff">9.77e-4</span>, <span style="color:#ae81ff">5.32e-5</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">8.48e-5</span>, <span style="color:#ae81ff">5.57e-5</span>, <span style="color:#ae81ff">5.56e-5</span>, <span style="color:#ae81ff">5.53e-6</span>, <span style="color:#ae81ff">7.74e-7</span>, <span style="color:#ae81ff">1.03e-5</span>, <span style="color:#ae81ff">8.75e-6</span> };
</span></span></code></pre></div><p>The number of grid points in the toroidal direction at which the magnetic axis geometry
is to be evaluated is specified via the <code>n_zeta</code> parameter.
It needs to be checked that <code>n_zeta</code> is large enough, i.e.,
above the Nyquist limit corresponding to the specified number of Fourier coefficients.
Then, the input and output arrays can be allocated:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> nCplx <span style="color:#f92672">=</span> n_zeta<span style="color:#f92672">/</span><span style="color:#ae81ff">2</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (nCplx<span style="color:#f92672">&lt;</span>ntor<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>    printf(<span style="color:#e6db74">&#34;error: number of grid points too low.</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>fftw_complex <span style="color:#f92672">*</span>in <span style="color:#f92672">=</span> fftw_alloc_complex(nCplx);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">double</span> <span style="color:#f92672">*</span>out <span style="color:#f92672">=</span> fftw_alloc_real(n_zeta);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>fftw_plan p <span style="color:#f92672">=</span> fftw_plan_dft_c2r_1d(n_zeta, in, out, FFTW_ESTIMATE);
</span></span></code></pre></div><p>Now that the input array is allocated,
the available Fourier coefficients can be copied over
and (if present) the remainder of the input array is set to zero:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#75715e">// copy over available Fourier coefficients
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> n<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; n<span style="color:#f92672">&lt;=</span>ntor; <span style="color:#f92672">++</span>n) {
</span></span><span style="display:flex;"><span>    in[n] <span style="color:#f92672">=</span> R_ax_cos[n] <span style="color:#f92672">-</span> I <span style="color:#f92672">*</span> R_ax_sin[n];
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// zero out remaining input Fourier coefficients
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> n<span style="color:#f92672">=</span>ntor<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>; n<span style="color:#f92672">&lt;</span>nCplx; <span style="color:#f92672">++</span>n) {
</span></span><span style="display:flex;"><span>    in[n] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The full example can be found in <a href="src/app_magn_axis.c"><code>src/app_magn_axis.c</code></a>.</p>
<p>Assuming <a href="https://doi.org/10.1016/S0167-2789%2897%2900216-9">stellarator symmetry</a>,
half of the Fourier coefficients can be omitted and the transform
reduces to the one-dimensional IDCT and IDST, respectively:</p>
<p><!-- raw HTML omitted -->$$</p>
<p>$$<!-- raw HTML omitted -->
<img src="eqn/magn_axis_stellsym.png" alt="stellarator-symmetric Fourier series for magnetic axis" /></p>
<p>The <a href="http://fftw.org/fftw3_doc/Real-even_002fodd-DFTs-_0028cosine_002fsine-transforms_0029.html#DOCF4">FFTW documentation</a>
explicitly advises against using <code>R*DFT00</code> transforms for this purpose due to numerical stability issues
which are currently circumvented within FFTW by using a less efficient algorithm.
If the data is required anyway on the whole domain from 0 to 2π,
it is probably easiest and fastest (in terms of development work)
to simply use a <code>c2r</code> DFT and provide only real data in the input.</p>
<p>On the other hand, in case the evaluation locations are not required to be located on
&ldquo;full&rdquo; grid points in the toroidal direction, <code>REDFT01</code> and  <code>RODFT01</code> can be used.
This is the subject of the now-starting second half of this example.</p>
<p>The number of grid points as well as the output array size are given as follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> nCplx <span style="color:#f92672">=</span> n_zeta <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (nCplx <span style="color:#f92672">&lt;</span> ntor <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>    printf(<span style="color:#e6db74">&#34;error: number of grid points too low.</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Only the cosine Fourier coefficients are copied over into the (real) input array:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#75715e">// copy over available Fourier coefficients
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>in[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> R_ax_cos[<span style="color:#ae81ff">0</span>];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> n <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; n <span style="color:#f92672">&lt;=</span> ntor; <span style="color:#f92672">++</span>n) {
</span></span><span style="display:flex;"><span>    in[n] <span style="color:#f92672">=</span> R_ax_cos[n];
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// zero out remaining input Fourier coefficients
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> n <span style="color:#f92672">=</span> ntor <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>; n <span style="color:#f92672">&lt;</span> nCplx; <span style="color:#f92672">++</span>n) {
</span></span><span style="display:flex;"><span>    in[n] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The second half of the output array (of size <code>n_zeta</code> for equivalent with the first half of this example)
is filled by applying the even symmetry of the output data implicitly used in <code>REDFT01</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> n<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; n<span style="color:#f92672">&lt;</span>nCplx; <span style="color:#f92672">++</span>n) {
</span></span><span style="display:flex;"><span>    out[n_zeta <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">-</span> n] <span style="color:#f92672">=</span> out[n];
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The output data is compared in the following figure with the equivalent result from using a <code>c2r</code> transform:</p>
<p><img src="img/axis_R.png" alt="R of magnetic axis: c2r DFT vs. REDFT01" /></p>
<p>The violet curve labelled &lsquo;DFT&rsquo; is the output from the <code>c2r</code> DFT applied in the first half of this example.
The green curve labelled &lsquo;REDFT01&rsquo; is the output from the <code>REDFT01</code> applied in the second half of this example.
Note that the locations of the <code>REDFT01</code> output needed to be shifted to the right by half an index to yield overlapping curves.</p>
<p>The full example can be found in <a href="src/app_magn_axis_stellsym.c"><code>src/app_magn_axis_stellsym.c</code></a>.</p>
<h3 id="geometry-of-a-flux-surface-in-a-stellarator">
  Geometry of a Flux Surface in a Stellarator
  <a class="anchor" href="#geometry-of-a-flux-surface-in-a-stellarator">#</a>
</h3>
<p>The real-space geometry of the flux surface is a general toroidal surface
which is conveniently parameterized using poloidal and toroidal angle-like coordinates.
The surface geometry is then given via a two-dimensional DFT:</p>
<p><!-- raw HTML omitted -->$$</p>
<p>$$<!-- raw HTML omitted -->
<img src="eqn/flux_surface.png" alt="full Fourier series for flux surface" /></p>
<p>where (θ,ζ) are the poloidal and toroidal angle-like variables in radians, respectively.
For a five-fold symmetric stellarator like W7-X, ζ ranges from 0 to 5 * 2π around the whole machine.
Conversely, the first (unique) toroidal segment of the geometry is contained within a range of ζ from 0 to 2π.
The poloidal angle-like coordinate θ ranges from 0 to 2π once the short way around the torus (wristband-like).</p>
<p>The two-dimensional DFT above can be simplified (shown here for <em>R</em> only)
by introducing rectangular two-dimensional Fourier coefficient matrices:</p>
<p><!-- raw HTML omitted -->$$</p>
<p>$$<!-- raw HTML omitted -->
<img src="eqn/vmec_2d_fc.png" alt="full 2d FC matrix for flux surface" /></p>
<p>In this example the geometry of the flux surface is evaluated
on a regular grid in θ and ζ:</p>
<p><!-- raw HTML omitted -->$$</p>
<p>$$<!-- raw HTML omitted -->
<img src="eqn/grid_zeta.png" alt="grid in zeta" /></p>
<p><!-- raw HTML omitted -->$$</p>
<p>$$<!-- raw HTML omitted -->
<img src="eqn/grid_theta.png" alt="grid in theta" /></p>
<p>where <em>l</em> ranges from <code>0</code> to <code>n_ζ-1</code> and <em>k</em> ranges from <code>0</code> to <code>n_θ-1</code>.</p>
<p>Inserting this into the Fourier series for, e.g., the <em>R</em> coordinate, leads to a DFT:</p>
<p><!-- raw HTML omitted -->$$</p>
<p>$$<!-- raw HTML omitted -->
<img src="eqn/flux_surface_dft.png" alt="flux surface R via DFT" /></p>
<p>The <em>R</em> coordinate is a real-valued quantity
which implies that a two-dimensional <code>c2r</code> DFT provided by FFTW can be used to
perform the backward transform in order to evaluate the flux surface geometry.
One further issue consists in the fact that the definition
of the Fourier geometry employed in VMEC uses an angle argument <em>(m θ - n ζ)</em>
where the two-dimensional DFT written out above uses <em>(m θ + n ζ)</em>.
The Fourier coefficients coming from VMEC
have to be inserted into the positions corresponding to <em>(-n)</em>
in the input array given to FFTW in order to resolve this pecularity.</p>
<p>The next part concers the code to copy over the Fourier coefficients
staring from the VMEC output in arrays <code>rmnc</code> and <code>zmns</code> into the input to FFTW.</p>
<p>The index in the FFTW input corresponding to given mode numbers <code>n</code> and <code>m</code>
can be computed as follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (n <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>    idx_in <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>n <span style="color:#f92672">*</span> nyq_pol <span style="color:#f92672">+</span> m;
</span></span><span style="display:flex;"><span>} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>    idx_in <span style="color:#f92672">=</span> (n_zeta <span style="color:#f92672">-</span> n) <span style="color:#f92672">*</span> nyq_pol <span style="color:#f92672">+</span> m;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This code is abbreviated in the following as <code>/* compute idx_in */</code>.</p>
<p>For the first coefficients with <code>m=0</code>,
the copying is performed as follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> idx_vmec <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> m <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> n <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; n <span style="color:#f92672">&lt;=</span> ntor; <span style="color:#f92672">++</span>n) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* compute idx_in */</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    in_R[idx_in] <span style="color:#f92672">=</span>     rmnc[idx_vmec];
</span></span><span style="display:flex;"><span>    in_Z[idx_in] <span style="color:#f92672">=</span> I <span style="color:#f92672">*</span> zmns[idx_vmec];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    idx_vmec<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Note that VMEC weights the coefficients for <code>m=0</code> with positive <code>n ζ</code>
in contrast to the following coefficients with <code>m&gt;0</code>.
The cosine-parity quantities like <em>R</em> are not influence by this,
but the sine-parity quantities like <em>Z</em> need to get the sign of their value flipped
due to the odd symmetry <code>sin(-n zeta) = -sin(n zeta)</code>.</p>
<p>The second part of the copying adresses the Fourier coefficients
with <code>m&gt;0</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (m <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; m <span style="color:#f92672">&lt;</span> mpol; <span style="color:#f92672">++</span>m) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> n <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>ntor; n <span style="color:#f92672">&lt;=</span> ntor; <span style="color:#f92672">++</span>n) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/* compute idx_in */</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        in_R[idx_in] <span style="color:#f92672">=</span>  <span style="color:#ae81ff">0.5</span> <span style="color:#f92672">*</span>     rmnc[idx_vmec];
</span></span><span style="display:flex;"><span>        in_Z[idx_in] <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">0.5</span> <span style="color:#f92672">*</span> I <span style="color:#f92672">*</span> zmns[idx_vmec];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        idx_vmec<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Here, the coefficients are scaled by a factor of <code>0.5</code>.
FFTW implies that coefficientss for <code>m&lt;0</code> were present in the logically equivalent DFT input,
which is not the case for VMEC output. Thus, they are (in this case errornously)
scaled internally by a factor of <code>2</code>, which needs to be counteracted by a scaling factor of <code>0.5</code> in the input.</p>
<p>Assuming <a href="https://doi.org/10.1016/S0167-2789%2897%2900216-9">stellarator symmetry</a>,
half of the Fourier coefficients can be omitted and the transform reduces to the two-dimensional IDCT and IDST:</p>
<p><!-- raw HTML omitted -->$$</p>
<p>$$<!-- raw HTML omitted -->
<img src="eqn/flux_surface_stellsym.png" alt="stellarator-symmetric Fourier series for flux surface" /></p>
<p>This is currently resolved by simply omitting the stellarator-asymmetric terms
in the input to FFTW.</p>
<p>The full example code can be found in <a href="src/app_flux_surface.c"><code>src/app_flux_surface.c</code></a>.
A Python script is provided to plot the resulting real-space geometry in <a href="src/plot_lcfs_realspace.py"><code>src/plot_lcfs_realspace.py</code></a>.</p>
<h2 id="allocation-of-arrays">
  Allocation of arrays
  <a class="anchor" href="#allocation-of-arrays">#</a>
</h2>
<p>Throughout this example collection, the proposed convenience wrapper functions provided by FFTW for allocating real- and complex-valued arrays are used:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> n <span style="color:#f92672">=</span> <span style="color:#ae81ff">32</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> nOut <span style="color:#f92672">=</span> n<span style="color:#f92672">/</span><span style="color:#ae81ff">2</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">double</span> <span style="color:#f92672">*</span>in <span style="color:#f92672">=</span> fftw_alloc_real(n);
</span></span><span style="display:flex;"><span>fftw_complex <span style="color:#f92672">*</span>out <span style="color:#f92672">=</span> fftw_alloc_complex(nOut);
</span></span></code></pre></div><p>where <code>n</code> is the real-space size of the DFT and <code>nOut</code> is the number of Fourier coefficients resulting from a <code>r2c</code> DFT.
The corresponding &ldquo;raw&rdquo; allocation code would look like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">double</span> <span style="color:#f92672">*</span>in <span style="color:#f92672">=</span> (<span style="color:#66d9ef">double</span><span style="color:#f92672">*</span>) fftw_malloc(<span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">double</span>) <span style="color:#f92672">*</span> n);
</span></span><span style="display:flex;"><span>fftw_complex <span style="color:#f92672">*</span>out <span style="color:#f92672">=</span> (fftw_complex<span style="color:#f92672">*</span>) fftw_malloc(<span style="color:#66d9ef">sizeof</span>(fftw_complex) <span style="color:#f92672">*</span> nOut);
</span></span></code></pre></div><p>Note that above code is equivalent to the standard C way of allocating memory using <code>malloc</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">double</span> <span style="color:#f92672">*</span>in <span style="color:#f92672">=</span> (<span style="color:#66d9ef">double</span><span style="color:#f92672">*</span>) malloc(<span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">double</span>) <span style="color:#f92672">*</span> n);
</span></span><span style="display:flex;"><span>fftw_complex <span style="color:#f92672">*</span>out <span style="color:#f92672">=</span> (fftw_complex<span style="color:#f92672">*</span>) malloc(<span style="color:#66d9ef">sizeof</span>(fftw_complex) <span style="color:#f92672">*</span> nOut);
</span></span></code></pre></div><p>except that the FFTW routines ensure proper memory alignment for exploiting SIMD instructions of modern CPUs.</p>
<h2 id="utility-functions">
  Utility functions
  <a class="anchor" href="#utility-functions">#</a>
</h2>
<p>In order to keep the examples short, a separate header file <a href="src/util.h"><code>src/util.h</code></a> is provided.
It contains methods to operate on one- and two-dimensional arrays (the latter stored in row-major order)
of real (<code>double</code>) and complex (<code>fftw_complex</code>) numbers.
The following operations are supported:</p>
<ul>
<li>fill with random numbers between 0 and 1: e.g. <code>fill_random_1d_cplx</code></li>
<li>element-wise check for approximate equality: e.g. <code>compare_1d_real</code></li>
<li>write into a text file: e.g. <code>dump_1d_real</code></li>
<li>compute generalized DFT (shift and non-linear phase): <code>dft_1d_cplx</code></li>
</ul>
</article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">



  <div><a class="flex align-center" href="https://github.com/jonathanschilling/labathome.de-content/commit/734c503f4b3b82a0fe06b144ee642e3427960a8a" title='Last modified by Jonathan Schilling | November 23, 2022' target="_blank" rel="noopener">
      <img src="/labathome.de/svg/calendar.svg" class="book-icon" alt="Calendar" />
      <span>November 23, 2022</span>
    </a>
  </div>



</div>

 
        
      </footer>

      
  
  <div class="book-comments">

</div>
  
 

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
    <aside class="book-toc">
      <div class="book-toc-content">
        
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#one-dimensional-examples">One-Dimensional Examples</a>
      <ul>
        <li><a href="#1d-complex-to-complex">1D complex-to-complex</a></li>
        <li><a href="#1d-complex-to-real-and-real-to-complex">1D complex-to-real and real-to-complex</a></li>
        <li><a href="#1d-real-to-real">1D real-to-real</a></li>
      </ul>
    </li>
    <li><a href="#two-dimensional-examples">Two-Dimensional Examples</a>
      <ul>
        <li><a href="#2d-complex-to-complex">2D complex-to-complex</a></li>
        <li><a href="#2d-complex-to-real">2D complex-to-real</a></li>
        <li><a href="#2d-real-to-complex">2D real-to-complex</a></li>
        <li><a href="#2d-real-to-real">2D real-to-real</a></li>
      </ul>
    </li>
    <li><a href="#real-world-applications">Real-world applications</a>
      <ul>
        <li><a href="#geometry-of-the-magnetic-axis-in-a-stellarator">Geometry of the Magnetic Axis in a Stellarator</a></li>
        <li><a href="#geometry-of-a-flux-surface-in-a-stellarator">Geometry of a Flux Surface in a Stellarator</a></li>
      </ul>
    </li>
    <li><a href="#allocation-of-arrays">Allocation of arrays</a></li>
    <li><a href="#utility-functions">Utility functions</a></li>
  </ul>
</nav>


 
      </div>
    </aside>
    
  </main>

  
</body>

</html>












